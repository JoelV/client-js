{"version":3,"sources":["webpack://FHIR/webpack/bootstrap","webpack://FHIR/./src/lib/index.ts","webpack://FHIR/./src/lib/settings.ts","webpack://FHIR/./src/lib/Client.ts","webpack://FHIR/./src/util.ts","webpack://FHIR/./src/browser.ts","webpack://FHIR/(webpack)/buildin/global.js","webpack://FHIR/./src/lib/HttpError.ts","webpack://FHIR/./node_modules/debug/src/browser.js","webpack://FHIR/./node_modules/process/browser.js","webpack://FHIR/./node_modules/debug/src/common.js","webpack://FHIR/./node_modules/debug/node_modules/ms/index.js","webpack://FHIR/./src/lib/smart.ts","webpack://FHIR/./src/lib/adapters/BrowserAdapter.ts","webpack://FHIR/./src/lib/storage/BrowserStorage.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","debug","fetch","window","_debug","cache","ensureNumerical","code","Error","async","checkResponse","resp","ok","error","parse","responseToJSON","text","then","length","JSON","request","url","requestOptions","includeResponse","options","headers","accept","res","type","match","body","status","location","method","response","undefined","getAndCache","force","Promise","resolve","getPath","obj","path","trim","segments","split","result","shift","Array","isArray","map","join","isBrowser","atob","str","global","Buffer","from","toString","jwtDecode","token","payload","units","any","pq","baseUrl","String","replace","catch","ex","createEmpty","reduce","out","idx","arr","strLength","charSet","len","push","charAt","Math","floor","random","btoa","tokenResponse","now","Date","expires_in","access_token","tokenBody","exp","conformance","resourceType","meta","find","searchParam","x","patientParams","target","width","height","self","parent","top","targetWindow","open","e","screen","winOrFrame","frames","condition","message","patientCompartment","fhirVersions","SMART_KEY","Response","extend","resolveRef","graph","client","signal","node","all","makeArray","filter","Boolean","item","ref","reference","refId","getRef","sub","indexOf","setPath","resolveRefs","fhirOptions","paths","resolveReferences","groups","forEach","task","keys","sort","group","msg","noPatientBeforeAuth","noPatientFromOpenServer","noPatientScopes","noPatientAvailable","noEncounterBeforeAuth","noEncounterFromOpenServer","noEncounterScopes","noEncounterAvailable","noUserBeforeAuth","noUserFromOpenServer","noUserScopes","noUserAvailable","requestNeedsArgs","appRequiresSMART","sessionExpiredAndNoRefresh","sessionExpired","autoRefreshFailed","requestGot403","cantRefreshNoToken","cantRefreshNoTokenUri","cantRefreshNoScopes","gotNoAccessToken","rejectedScopes","noExpiresAt","state","refreshWithCredentials","_refreshTask","serverUrl","assert","assign","this","patient","getPatientId","read","id","reject","base","absolute","contextualURL","_url","pathname","pop","fetchConformanceStatement","getPatientParam","searchParams","set","href","URL","contextualize","encounter","getEncounterId","user","getFhirUser","getUserId","getUserType","fhirUser","connect","fhir","checkScopes","expiresAt","tokenUri","refresh_token","hasGrantedScope","console","warn","fhirJs","accessToken","getState","auth","username","password","pass","api","patientId","scope","requestedScopes","grantedScopes","requested","authorizeUri","idToken","id_token","hasOpenid","hasProfile","hasFhirUser","getIdToken","slice","profile","save","resource","stringify","_resolvedRefs","debugRequest","flat","pageLimit","useRefreshToken","onPage","refreshIfNeeded","authHeader","getAuthorizationHeader","Authorization","saveState","data","_data","entry","links","link","next","relation","nextPage","references","concat","refreshToken","refresh","debugRefresh","hasOfflineAccess","hasOnlineAccess","refreshRequestOptions","credentials","encodeURIComponent","clientSecret","clientId","authorization","getAccessTokenExpiration","finally","observations","byCode","byCodes","metadata","fhirVersion","getFhirVersion","v","ret","handleCodeableConcept","concept","observation","coding","arg","bank","codes","prev","adapter","FHIR","Client","SMART","authorize","smart","ready","onSuccess","onError","init","util","g","Function","HttpError","super","statusText","statusCode","bodyUsed","json","error_description","log","args","formatArgs","useColors","namespace","humanize","diff","color","splice","index","lastC","namespaces","storage","setItem","removeItem","load","getItem","process","env","DEBUG","__nwjs","navigator","userAgent","toLowerCase","document","documentElement","style","WebkitAppearance","firebug","exception","table","parseInt","RegExp","$1","localStorage","localstorage","colors","formatters","j","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","setTimeout","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","timeout","run","marker","runClearTimeout","Item","array","noop","nextTick","arguments","apply","title","browser","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","selectColor","hash","charCodeAt","createDebug","abs","prevTime","enabled","curr","Number","ms","coerce","unshift","format","formatter","val","destroy","instances","delimiter","newDebug","toNamespace","regexp","substring","default","stack","disable","names","skips","enable","substr","instance","test","h","plural","msAbs","isPlural","round","exec","parseFloat","isNaN","long","fmtLong","fmtShort","fetchWellKnownJson","getSecurityExtensionsFromWellKnownJson","authorization_endpoint","token_endpoint","registrationUri","registration_endpoint","getSecurityExtensionsFromConformanceStatement","extensions","extension","ext","valueUri","tasks","errors","resolved","promise","complete","controller","abort","getSecurityExtensions","AbortController","getAbortController","abortController1","abortController2","params","getUrl","urlISS","cfg","issMatch","fakeTokenResponse","encounterId","noRedirect","multiple","iss","launch","fhirServiceUrl","redirectUri","completeInTarget","getStorage","relative","inFrame","isInFrame","inPopUp","isInPopUp","stateKey","randomString","redirectUrl","redirect","redirectParams","win","getTargetWindow","sessionStorage","addEventListener","onMessage","opener","origin","removeEventListener","completeAuth","Storage","authError","authErrorDescription","postMessage","close","delete","stored","buildTokenRequest","getAccessToken","history","replaceState","cleanUpUrl","getClient","cached","_storage","replaceBrowserHistory","refreshTokenWithCredentials","to","clear"],"mappings":"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","file":"fhir-client.pure.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","/*\n * This file contains some shared functions. They are used by other modules, but\n * are defined here so that tests can import this library and test them.\n */\n\nimport HttpError from \"./HttpError\";\nimport { patientParams } from \"./settings\";\nimport { fhirclient } from \"../types\";\nconst debug = require(\"debug\");\n\n// $lab:coverage:off$\n// @ts-ignore\nconst { fetch } = typeof FHIRCLIENT_PURE !== \"undefined\" ? window : require(\"cross-fetch\");\n// $lab:coverage:on$\n\nconst _debug     = debug(\"FHIR\");\nexport { _debug as debug };\n\n/**\n * The cache for the `getAndCache` function\n */\nconst cache: fhirclient.JsonObject = {};\n\n/**\n * A namespace with functions for converting between different measurement units\n */\nexport const units = {\n    cm({ code, value }: fhirclient.CodeValue) {\n        ensureNumerical({ code, value });\n        if (code == \"cm\"     ) return value;\n        if (code == \"m\"      ) return value *   100;\n        if (code == \"in\"     ) return value *  2.54;\n        if (code == \"[in_us]\") return value *  2.54;\n        if (code == \"[in_i]\" ) return value *  2.54;\n        if (code == \"ft\"     ) return value * 30.48;\n        if (code == \"[ft_us]\") return value * 30.48;\n        throw new Error(\"Unrecognized length unit: \" + code);\n    },\n    kg({ code, value }: fhirclient.CodeValue){\n        ensureNumerical({ code, value });\n        if (code == \"kg\"    ) return value;\n        if (code == \"g\"     ) return value / 1000;\n        if (code.match(/lb/)) return value / 2.20462;\n        if (code.match(/oz/)) return value / 35.274;\n        throw new Error(\"Unrecognized weight unit: \" + code);\n    },\n    any(pq: fhirclient.CodeValue){\n        ensureNumerical(pq);\n        return pq.value;\n    }\n};\n\n/**\n * Assertion function to guard arguments for `units` functions\n */\nfunction ensureNumerical({ value, code }: fhirclient.CodeValue) {\n    if (typeof value !== \"number\") {\n        throw new Error(\"Found a non-numerical unit: \" + value + \" \" + code);\n    }\n}\n\n/**\n * Used in fetch Promise chains to reject if the \"ok\" property is not true\n */\nexport async function checkResponse(resp: Response): Promise<Response> {\n    if (!resp.ok) {\n        const error = new HttpError(resp);\n        await error.parse();\n        throw error;\n    }\n    return resp;\n}\n\n/**\n * Used in fetch Promise chains to return the JSON version of the response.\n * Note that `resp.json()` will throw on empty body so we use resp.text()\n * instead.\n */\nexport function responseToJSON(resp: Response): Promise<object|string> {\n    return resp.text().then(text => text.length ? JSON.parse(text) : \"\");\n}\n\n/**\n * This is our built-in request function. It does a few things by default\n * (unless told otherwise):\n * - Makes CORS requests\n * - Sets accept header to \"application/json\"\n * - Handles errors\n * - If the response is json return the json object\n * - If the response is text return the result text\n * - Otherwise return the response object on which we call stuff like `.blob()`\n */\nexport function request<T = fhirclient.FetchResult>(\n    url: string | Request,\n    requestOptions: fhirclient.FetchOptions = {}\n): Promise<T>\n{\n    const { includeResponse, ...options } = requestOptions;\n    return fetch(url, {\n        mode: \"cors\",\n        ...options,\n        headers: {\n            accept: \"application/json\",\n            ...options.headers\n        }\n    })\n    .then(checkResponse)\n    .then((res: Response) => {\n        const type = res.headers.get(\"Content-Type\") + \"\";\n        if (type.match(/\\bjson\\b/i)) {\n            return responseToJSON(res).then(body => ({ res, body }));\n        }\n        if (type.match(/^text\\//i)) {\n            return res.text().then(body => ({ res, body }));\n        }\n        return { res };\n    })\n    .then(({res, body}: {res:Response, body?:fhirclient.JsonObject|string}) => {\n\n        // Some servers will reply after CREATE with json content type but with\n        // empty body. In this case check if a location header is received and\n        // fetch that to use it as the final result.\n        if (!body && res.status == 201) {\n            const location = res.headers.get(\"location\");\n            if (location) {\n                return request(location, { ...options, method: \"GET\", body: null, includeResponse });\n            }\n        }\n\n        if (includeResponse) {\n            return { body, response: res };\n        }\n\n        // For any non-text and non-json response return the Response object.\n        // This to let users decide if they want to call text(), blob() or\n        // something else on it\n        if (body === undefined) {\n            return res;\n        }\n\n        // Otherwise just return the parsed body (can also be \"\" or null)\n        return body;\n    });\n}\n\n/**\n * Makes a request using `fetch` and stores the result in internal memory cache.\n * The cache is cleared when the page is unloaded.\n * @param url The URL to request\n * @param requestOptions Request options\n * @param force If true, reload from source and update the cache, even if it has\n * already been cached.\n */\nexport function getAndCache(url: string, requestOptions?: RequestInit, force: boolean = process.env.NODE_ENV === \"test\"): Promise<any> {\n    if (force || !cache[url]) {\n        cache[url] = request(url, requestOptions);\n        return cache[url];\n    }\n    return Promise.resolve(cache[url]);\n}\n\n/**\n * Fetches the conformance statement from the given base URL.\n * Note that the result is cached in memory (until the page is reloaded in the\n * browser) because it might have to be re-used by the client\n * @param baseUrl The base URL of the FHIR server\n * @param [requestOptions] Any options passed to the fetch call\n */\nexport function fetchConformanceStatement(baseUrl = \"/\", requestOptions?: RequestInit): Promise<fhirclient.FHIR.CapabilityStatement>\n{\n    const url = String(baseUrl).replace(/\\/*$/, \"/\") + \"metadata\";\n    return getAndCache(url, requestOptions).catch((ex: Error) => {\n        throw new Error(\n            `Failed to fetch the conformance statement from \"${url}\". ${ex}`\n        );\n    });\n}\n\n\n/**\n * Walks through an object (or array) and returns the value found at the\n * provided path. This function is very simple so it intentionally does not\n * support any argument polymorphism, meaning that the path can only be a\n * dot-separated string. If the path is invalid returns undefined.\n * @param obj The object (or Array) to walk through\n * @param path The path (eg. \"a.b.4.c\")\n * @returns {*} Whatever is found in the path or undefined\n */\nexport function getPath(obj: fhirclient.JsonObject, path = \"\"): any {\n    path = path.trim();\n    if (!path) {\n        return obj;\n    }\n\n    let segments = path.split(\".\");\n    let result = obj;\n\n    while (result && segments.length) {\n        const key = segments.shift();\n        if (!key && Array.isArray(result)) {\n            return result.map(o => getPath(o, segments.join(\".\")));\n        } else {\n            result = result[key as string];\n        }\n    }\n\n    return result;\n}\n\n/**\n * Like getPath, but if the node is found, its value is set to @value\n * @param obj The object (or Array) to walk through\n * @param path The path (eg. \"a.b.4.c\")\n * @param value The value to set\n * @param createEmpty If true, create missing intermediate objects or arrays\n * @returns The modified object\n */\nexport function setPath(obj: fhirclient.JsonObject, path: string, value: any, createEmpty = false): fhirclient.JsonObject {\n    path.trim().split(\".\").reduce(\n        (out, key, idx, arr) => {\n            if (out && idx === arr.length - 1) {\n                out[key] = value;\n            }\n            else {\n                if (out && out[key] === undefined && createEmpty) {\n                    out[key] = arr[idx + 1].match(/^[0-9]+$/) ? [] : {};\n                }\n                return out ? out[key] : undefined;\n            }\n        },\n        obj\n    );\n    return obj;\n}\n\n/**\n * Given a path, converts it to absolute url based on the `baseUrl`. If baseUrl\n * is not provided, the result would be a rooted path (one that starts with `/`).\n * @param path The path to convert\n * @param baseUrl The base URL\n */\nexport function absolute(path: string, baseUrl?: string): string\n{\n    if (path.match(/^http/)) return path;\n    if (path.match(/^urn/)) return path;\n    return String(baseUrl || \"\").replace(/\\/+$/, \"\") + \"/\" + path.replace(/^\\/+/, \"\");\n}\n\n/**\n * Generates random strings. By default this returns random 8 characters long\n * alphanumeric strings.\n * @param strLength The length of the output string. Defaults to 8.\n * @param charSet A string containing all the possible characters.\n *     Defaults to all the upper and lower-case letters plus digits.\n * @category Utility\n */\nexport function randomString(\n    strLength = 8,\n    charSet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"\n): string\n{\n    const result = [];\n    const len = charSet.length;\n    while (strLength--) {\n        result.push(charSet.charAt(Math.floor(Math.random() * len)));\n    }\n    return result.join(\"\");\n}\n\nexport function isBrowser()\n{\n    return typeof window === \"object\";\n}\n\n/**\n * Base64 to ASCII\n */\nexport function atob(str: string): string\n{\n     return isBrowser() ?\n\n        // Browsers have global atob method\n        window.atob(str) :\n        \n        // \"global.\" helps Webpack understand that it doesn't have to\n        // include the Buffer code in the bundle\n        global.Buffer.from(str, \"base64\").toString(\"ascii\");\n}\n\n/**\n * ASCII to Base64\n */\nexport function btoa(str: string): string\n{\n    return isBrowser() ?\n\n        // Browsers have global btoa method\n        window.btoa(str) :\n        \n        // \"global.\" helps Webpack understand that it doesn't have to\n        // include the Buffer code in the bundle\n        global.Buffer.from(str).toString(\"base64\");\n}\n\n/**\n * Decodes a JWT token and returns it's body.\n * @param token The token to read\n * @param env An `Adapter` or any other object that has an `atob` method\n * @category Utility\n */\nexport function jwtDecode(token: string): fhirclient.JsonObject | null\n{\n    const payload = token.split(\".\")[1];\n    return payload ? JSON.parse(atob(payload)) : null;\n}\n\n/**\n * Given a token response, computes and returns the expiresAt timestamp.\n * Note that this should only be used immediately after an access token is\n * received, otherwise the computed timestamp will be incorrect.\n * @param tokenResponse \n * @param env \n */\nexport function getAccessTokenExpiration(tokenResponse: fhirclient.TokenResponse): number\n{\n    const now = Math.floor(Date.now() / 1000);\n\n    // Option 1 - using the expires_in property of the token response\n    if (tokenResponse.expires_in) {\n        return now + tokenResponse.expires_in;\n    }\n\n    // Option 2 - using the exp property of JWT tokens (must not assume JWT!)\n    if (tokenResponse.access_token) {\n        let tokenBody = jwtDecode(tokenResponse.access_token);\n        if (tokenBody && tokenBody.exp) {\n            return tokenBody.exp;\n        }\n    }\n\n    // Option 3 - if none of the above worked set this to 5 minutes after now\n    return now + 300;\n}\n\n/**\n * Given a conformance statement and a resource type, returns the name of the\n * URL parameter that can be used to scope the resource type by patient ID.\n */\nexport function getPatientParam(conformance: fhirclient.FHIR.CapabilityStatement, resourceType: string): string\n{\n    // Find what resources are supported by this server\n    const resources = getPath(conformance, \"rest.0.resource\") || [];\n\n    // Check if this resource is supported\n    const meta = resources.find((r: any) => r.type === resourceType);\n    if (!meta) {\n        throw new Error(`Resource \"${resourceType}\" is not supported by this FHIR server`);\n    }\n\n    // Check if any search parameters are available for this resource\n    if (!Array.isArray(meta.searchParam)) {\n        throw new Error(`No search parameters supported for \"${resourceType}\" on this FHIR server`);\n    }\n\n    // This is a rare case but could happen in generic workflows\n    if (resourceType == \"Patient\" && meta.searchParam.find((x: any) => x.name == \"_id\")) {\n        return \"_id\";\n    }\n\n    // Now find the first possible parameter name\n    const out = patientParams.find(p => meta.searchParam.find((x: any) => x.name == p));\n\n    // If there is no match\n    if (!out) {\n        throw new Error(\"I don't know what param to use for \" + resourceType);\n    }\n\n    return out;\n}\n\n/**\n * Resolves a reference to target window. It may also open new window or tab if\n * the `target = \"popup\"` or `target = \"_blank\"`.\n * @param target\n * @param width Only used when `target = \"popup\"`\n * @param height Only used when `target = \"popup\"`\n */\nexport async function getTargetWindow(target: fhirclient.WindowTarget, width: number = 800, height: number = 720): Promise<Window>\n{\n    // The target can be a function that returns the target. This can be\n    // used to open a layer pop-up with an iframe and then return a reference\n    // to that iframe (or its name)\n    if (typeof target == \"function\") {\n        target = await target();\n    }\n\n    // The target can be a window reference\n    if (target && typeof target == \"object\") {\n        return target;\n    }\n\n    // At this point target must be a string\n    if (typeof target != \"string\") {\n        _debug(\"Invalid target type '%s'. Failing back to '_self'.\", typeof target);\n        return self;\n    }\n\n    // Current window\n    if (target == \"_self\") {\n        return self;\n    }\n\n    // The parent frame\n    if (target == \"_parent\") {\n        return parent;\n    }\n\n    // The top window\n    if (target == \"_top\") {\n        return top;\n    }\n\n    // New tab or window\n    if (target == \"_blank\") {\n        let error, targetWindow: Window | null = null;\n        try {\n            targetWindow = window.open(\"\", \"SMARTAuthPopup\");\n            if (!targetWindow) {\n                throw new Error(\"Perhaps window.open was blocked\");\n            }\n        } catch (e) {\n            error = e;\n        }\n\n        if (!targetWindow) {\n            _debug(\"Cannot open window. Failing back to '_self'. %s\", error);\n            return self;\n        } else {\n            return targetWindow;\n        }\n    }\n\n    // Popup window\n    if (target == \"popup\") {\n        let error, targetWindow: Window | null = null;\n        // if (!targetWindow || targetWindow.closed) {\n        try {\n            targetWindow = window.open(\"\", \"SMARTAuthPopup\", [\n                \"height=\" + height,\n                \"width=\" + width,\n                \"menubar=0\",\n                \"resizable=1\",\n                \"status=0\",\n                \"top=\" + (screen.height - height) / 2,\n                \"left=\" + (screen.width - width) / 2\n            ].join(\",\"));\n            if (!targetWindow) {\n                throw new Error(\"Perhaps the popup window was blocked\");\n            }\n        } catch (e) {\n            error = e;\n        }\n\n        if (!targetWindow) {\n            _debug(\"Cannot open window. Failing back to '_self'. %s\", error);\n            return self;\n        } else {\n            return targetWindow;\n        }\n    }\n\n    // Frame or window by name\n    const winOrFrame: Window = frames[target as any];\n    if (winOrFrame) {\n        return winOrFrame;\n    }\n\n    _debug(\"Unknown target '%s'. Failing back to '_self'.\", target);\n    return self;\n}\n\nexport function assert(condition: any, message: string): asserts condition {\n    if (!(condition)) {\n        throw new Error(message)\n    }\n}\n","/**\n * Combined list of FHIR resource types accepting patient parameter in FHIR R2-R4\n */\nexport const patientCompartment = [\n    \"Account\",\n    \"AdverseEvent\",\n    \"AllergyIntolerance\",\n    \"Appointment\",\n    \"AppointmentResponse\",\n    \"AuditEvent\",\n    \"Basic\",\n    \"BodySite\",\n    \"BodyStructure\",\n    \"CarePlan\",\n    \"CareTeam\",\n    \"ChargeItem\",\n    \"Claim\",\n    \"ClaimResponse\",\n    \"ClinicalImpression\",\n    \"Communication\",\n    \"CommunicationRequest\",\n    \"Composition\",\n    \"Condition\",\n    \"Consent\",\n    \"Coverage\",\n    \"CoverageEligibilityRequest\",\n    \"CoverageEligibilityResponse\",\n    \"DetectedIssue\",\n    \"DeviceRequest\",\n    \"DeviceUseRequest\",\n    \"DeviceUseStatement\",\n    \"DiagnosticOrder\",\n    \"DiagnosticReport\",\n    \"DocumentManifest\",\n    \"DocumentReference\",\n    \"EligibilityRequest\",\n    \"Encounter\",\n    \"EnrollmentRequest\",\n    \"EpisodeOfCare\",\n    \"ExplanationOfBenefit\",\n    \"FamilyMemberHistory\",\n    \"Flag\",\n    \"Goal\",\n    \"Group\",\n    \"ImagingManifest\",\n    \"ImagingObjectSelection\",\n    \"ImagingStudy\",\n    \"Immunization\",\n    \"ImmunizationEvaluation\",\n    \"ImmunizationRecommendation\",\n    \"Invoice\",\n    \"List\",\n    \"MeasureReport\",\n    \"Media\",\n    \"MedicationAdministration\",\n    \"MedicationDispense\",\n    \"MedicationOrder\",\n    \"MedicationRequest\",\n    \"MedicationStatement\",\n    \"MolecularSequence\",\n    \"NutritionOrder\",\n    \"Observation\",\n    \"Order\",\n    \"Patient\",\n    \"Person\",\n    \"Procedure\",\n    \"ProcedureRequest\",\n    \"Provenance\",\n    \"QuestionnaireResponse\",\n    \"ReferralRequest\",\n    \"RelatedPerson\",\n    \"RequestGroup\",\n    \"ResearchSubject\",\n    \"RiskAssessment\",\n    \"Schedule\",\n    \"ServiceRequest\",\n    \"Specimen\",\n    \"SupplyDelivery\",\n    \"SupplyRequest\",\n    \"VisionPrescription\"\n];\n\n/**\n * Map of FHIR releases and their abstract version as number\n */\nexport const fhirVersions = {\n    \"0.4.0\": 2,\n    \"0.5.0\": 2,\n    \"1.0.0\": 2,\n    \"1.0.1\": 2,\n    \"1.0.2\": 2,\n    \"1.1.0\": 3,\n    \"1.4.0\": 3,\n    \"1.6.0\": 3,\n    \"1.8.0\": 3,\n    \"3.0.0\": 3,\n    \"3.0.1\": 3,\n    \"3.3.0\": 4,\n    \"3.5.0\": 4,\n    \"4.0.0\": 4,\n    \"4.0.1\": 4\n};\n\n/**\n * Combined (FHIR R2-R4) list of search parameters that can be used to scope\n * a request by patient ID.\n */\nexport const patientParams = [\n    \"patient\",\n    \"subject\",\n    \"requester\",\n    \"member\",\n    \"actor\",\n    \"beneficiary\"\n];\n\n/**\n * The name of the sessionStorage entry that contains the current key\n */\nexport const SMART_KEY = \"SMART_KEY\";\n","import {\n    absolute,\n    debug as _debug,\n    getPath,\n    setPath,\n    jwtDecode,\n    request,\n    units,\n    getPatientParam,\n    fetchConformanceStatement,\n    getAccessTokenExpiration,\n    btoa,\n    isBrowser,\n    assert\n} from \".\";\nimport { byCode, byCodes, makeArray } from \"../util\"\nimport { patientCompartment, fhirVersions } from \"./settings\";\nimport HttpError from \"./HttpError\";\nimport { fhirclient } from \"../types\";\n\n// $lab:coverage:off$\n// @ts-ignore\nconst { Response } = typeof FHIRCLIENT_PURE !== \"undefined\" ? window : require(\"cross-fetch\");\n// $lab:coverage:on$\n\nconst debug = _debug.extend(\"client\");\n\n/**\n * Adds patient context to requestOptions object to be used with [[Client.request]]\n * @param requestOptions Can be a string URL (relative to the serviceUrl), or an\n * object which will be passed to fetch()\n * @param client Current FHIR client object containing patient context\n * @return requestOptions object contextualized to current patient\n */\nasync function contextualize(\n    requestOptions: string | URL | fhirclient.RequestOptions,\n    client: Client\n): Promise<fhirclient.RequestOptions>\n{\n    const base = absolute(\"/\", client.state.serverUrl);\n\n    async function contextualURL(_url: URL) {\n        const resourceType = _url.pathname.split(\"/\").pop();\n\n        assert(resourceType, `Invalid url \"${_url}\"`);\n\n        assert(patientCompartment.indexOf(resourceType) > -1, `Cannot filter \"${resourceType}\" resources by patient`);\n\n        const conformance = await fetchConformanceStatement(client.state.serverUrl);\n        const searchParam = getPatientParam(conformance, resourceType);\n        _url.searchParams.set(searchParam, client.patient.id as string);\n        return _url.href;\n    }\n\n    if (typeof requestOptions == \"string\" || requestOptions instanceof URL) {\n        return { url: await contextualURL(new URL(requestOptions + \"\", base)) };\n    }\n\n    requestOptions.url = await contextualURL(new URL(requestOptions.url + \"\", base));\n    return requestOptions;\n}\n\n/**\n * Gets single reference by id. Caches the result.\n * @param refId\n * @param cache A map to store the resolved refs\n * @param client The client instance\n * @param [signal] The `AbortSignal` if any\n * @returns The resolved reference\n * @private\n */\nfunction getRef(\n    refId: string,\n    cache: fhirclient.JsonObject,\n    client: Client,\n    signal?: AbortSignal\n): Promise<fhirclient.JsonObject> {\n    if (!cache[refId]) {\n\n        // Note that we set cache[refId] immediately! When the promise is\n        // settled it will be updated. This is to avoid a ref being fetched\n        // twice because some of these requests are executed in parallel.\n        cache[refId] = client.request({\n            url: refId,\n            signal\n        }).then(res => {\n            cache[refId] = res;\n            return res;\n        }, (error: Error) => {\n            delete cache[refId];\n            throw error;\n        });\n    }\n\n    return Promise.resolve(cache[refId]);\n}\n\n/**\n * Resolves a reference in the given resource.\n * @param obj FHIR Resource\n */\nfunction resolveRef(\n    obj: fhirclient.FHIR.Resource,\n    path: string,\n    graph: boolean,\n    cache: fhirclient.JsonObject,\n    client: Client,\n    signal?: AbortSignal\n) {\n    const node = getPath(obj, path);\n    if (node) {\n        const isArray = Array.isArray(node);\n        return Promise.all(makeArray(node).filter(Boolean).map((item, i) => {\n            const ref = item.reference;\n            if (ref) {\n                return getRef(ref, cache, client, signal).then(sub => {\n                    if (graph) {\n                        if (isArray) {\n                            if (path.indexOf(\"..\") > -1) {\n                                setPath(obj, `${path.replace(\"..\", `.${i}.`)}`, sub);    \n                            } else {\n                                setPath(obj, `${path}.${i}`, sub);\n                            }\n                        } else {\n                            setPath(obj, path, sub);\n                        }\n                    }\n                }).catch((ex) => {\n                    /* ignore missing references */\n                    if (ex.status !== 404) {\n                        throw ex;\n                    }\n                });\n            }\n        }));\n    }\n}\n\n/**\n * Given a resource and a list of ref paths - resolves them all\n * @param obj FHIR Resource\n * @param fhirOptions The fhir options of the initiating request call\n * @param cache A map to store fetched refs\n * @param client The client instance\n * @private\n */\nfunction resolveRefs(\n    obj: fhirclient.FHIR.Resource,\n    fhirOptions: fhirclient.FhirOptions,\n    cache: fhirclient.JsonObject,\n    client: Client,\n    signal?: AbortSignal\n) {\n\n    // 1. Sanitize paths, remove any invalid ones\n    let paths = makeArray(fhirOptions.resolveReferences)\n        .filter(Boolean) // No false, 0, null, undefined or \"\"\n        .map(path => String(path).trim())\n        .filter(Boolean); // No space-only strings\n\n    // 2. Remove duplicates\n    paths = paths.filter((p, i) => {\n        const index = paths.indexOf(p, i + 1);\n        if (index > -1) {\n            debug(\"Duplicated reference path \\\"%s\\\"\", p);\n            return false;\n        }\n        return true;\n    });\n\n    // 3. Early exit if no valid paths are found\n    if (!paths.length) {\n        return Promise.resolve();\n    }\n\n    // 4. Group the paths by depth so that child refs are looked up\n    // after their parents!\n    const groups: fhirclient.JsonObject = {};\n    paths.forEach(path => {\n        const len = path.split(\".\").length;\n        if (!groups[len]) {\n            groups[len] = [];\n        }\n        groups[len].push(path);\n    });\n\n    // 5. Execute groups sequentially! Paths within same group are\n    // fetched in parallel!\n    let task: Promise<any> = Promise.resolve();\n    Object.keys(groups).sort().forEach(len => {\n        const group = groups[len];\n        task = task.then(() => Promise.all(group.map((path: string) => {\n            return resolveRef(obj, path, !!fhirOptions.graph, cache, client, signal);\n        })));\n    });\n    return task;\n}\n\nexport const msg = {\n    noPatientBeforeAuth       : \"Cannot get the ID of the selected patient before the app is authorized\",\n    noPatientFromOpenServer   : \"Cannot get the ID of the selected patient from an open FHIR server\",\n    noPatientScopes           : \"Unable to get the ID of the selected patient. Insufficient scopes. 'launch' or 'launch/patient' scope is needed.\",\n    noPatientAvailable        : \"The ID of the selected patient is not available. Please check if the server supports that.\",\n\n    noEncounterBeforeAuth     : \"Cannot get the ID of the selected encounter before the app is authorized\",\n    noEncounterFromOpenServer : \"Cannot get the ID of the selected encounter from an open FHIR server\",\n    noEncounterScopes         : \"Unable to get the ID of the selected encounter. Insufficient scopes. 'launch' or 'launch/encounter' scope is needed.\",\n    noEncounterAvailable      : \"The ID of the selected encounter is not available. Check if this server supports encounter context, and if the selected patient has any recorded encounters.\",\n\n    noUserBeforeAuth          : \"Cannot get the current user before the app is authorized\",\n    noUserFromOpenServer      : \"Cannot get the current user from an open FHIR server\",\n    noUserScopes              : \"Unable to get the current user. Insufficient scopes. 'openid fhirUser' or 'openid profile' scopes are needed.\",\n    noUserAvailable           : \"The current user is not available. Check if this server supports id tokens.\",\n\n    requestNeedsArgs          : \"request requires an url or request options as argument\",\n    appRequiresSMART          : \"This app cannot be accessed directly. Please launch it as SMART app!\",\n    sessionExpiredAndNoRefresh: \"Your session has expired and the useRefreshToken option is set to false. Please re-launch the app.\",\n    sessionExpired            : \"Session expired! Please re-launch the app.\",\n    autoRefreshFailed         : \"Auto-refresh failed! Please re-launch the app.\",\n    requestGot403             : \"Permission denied! Please make sure that you have requested the proper scopes.\",\n    cantRefreshNoToken        : \"Unable to refresh. No refresh_token found.\",\n    cantRefreshNoTokenUri     : \"Unable to refresh. No tokenUri found.\",\n    cantRefreshNoScopes       : \"Unable to refresh. No offline_access or online_access scope found.\",\n    gotNoAccessToken          : \"No access token received\",\n\n    rejectedScopes            : \"The following scopes were requested but not granted by the auth server: \\\"%s\\\"\",\n    noExpiresAt               : \"Auto-refresh might fail! The client got an access token but can't reliably determine when it will expire. The client \" +\n                                \"does not know when that access token was issued. Please also provide an 'expiresAt' state parameter.\"\n};\n\n/**\n * This is a FHIR client that is returned to you from the `ready()` call of the\n * **SMART API**. You can also create it yourself if needed:\n *\n * ```js\n * // BROWSER\n * const client = FHIR.client(\"https://r4.smarthealthit.org\");\n *\n * // SERVER\n * const client = new Client(\"https://r4.smarthealthit.org\");\n * ```\n */\nexport class Client\n{\n    /**\n     * The state of the client instance is an object with various properties.\n     * It contains some details about how the client has been authorized and\n     * determines the behavior of the client instance. If a `storage` is\n     * passed to the constructor, this state will also be persisted there.\n     */\n    readonly state: fhirclient.SMARTState;\n\n    readonly options: fhirclient.ClientOptions = {\n        refreshWithCredentials: \"same-origin\"\n    };\n\n    /**\n     * A SMART app is typically associated with a patient. This is a namespace\n     * for the patient-related functionality of the client.\n     */\n    readonly patient: {\n\n        /**\n         * The ID of the current patient or `null` if there is no current patient\n         */\n        id: string | null\n\n        /**\n         * A method to fetch the current patient resource from the FHIR server.\n         * If there is no patient context, it will reject with an error.\n         * @param {fhirclient.FetchOptions} [requestOptions] Any options to pass to the `fetch` call.\n         * @category Request\n         * @method\n         */\n        read: fhirclient.RequestFunction<fhirclient.FHIR.Patient>\n\n        /**\n         * This is similar to [[Client.request]] but it makes requests in the\n         * context of the current patient. For example, instead of doing\n         * ```js\n         * client.request(\"Observation?patient=\" + client.patient.id)\n         * ```\n         * you can do\n         * ```js\n         * client.patient.request(\"Observation\")\n         * ```\n         * The return type depends on the arguments. Typically it will be the\n         * response payload JSON object. Can also be a string or the `Response`\n         * object itself if we have received a non-json result, which allows us\n         * to handle even binary responses. Can also be a [[CombinedFetchResult]]\n         * object if the `requestOptions.includeResponse`s has been set to true.\n         * @category Request\n         * @method\n         */\n        request: <R = fhirclient.FetchResult>(\n            requestOptions: string|URL|fhirclient.RequestOptions,\n            fhirOptions?: fhirclient.FhirOptions\n        ) => Promise<R>\n\n        /**\n         * This is the FhirJS Patient API. It will ONLY exist if the `Client`\n         * instance is \"connected\" to FhirJS.\n         * @deprecated FhirJS integration will be removed in the next major release\n         */\n        api?: fhirclient.JsonObject\n    };\n\n    /**\n     * The client may be associated with a specific encounter, if the scopes\n     * permit that and if the back-end server supports that. This is a namespace\n     * for encounter-related functionality.\n     */\n    readonly encounter: {\n\n        /**\n         * The ID of the current encounter or `null` if there is no current\n         * encounter\n         */\n        id: string | null\n\n        /**\n         * A method to fetch the current encounter resource from the FHIR server.\n         * If there is no encounter context, it will reject with an error.\n         * @param [requestOptions] Any options to pass to the `fetch` call.\n         * @category Request\n         */\n        read: fhirclient.RequestFunction<fhirclient.FHIR.Encounter>\n    };\n\n    /**\n     * The client may be associated with a specific user, if the scopes\n     * permit that. This is a namespace for user-related functionality.\n     */\n    readonly user: {\n\n        /**\n         * The ID of the current user or `null` if there is no current user\n         */\n        id: string | null\n\n        /**\n         * A method to fetch the current user resource from the FHIR server.\n         * If there is no user context, it will reject with an error.\n         * @param [requestOptions] Any options to pass to the `fetch` call.\n         * @category Request\n         */\n        read: fhirclient.RequestFunction<\n            fhirclient.FHIR.Patient |\n            fhirclient.FHIR.Practitioner |\n            fhirclient.FHIR.RelatedPerson\n        >\n\n        /**\n         * Returns the profile of the logged_in user (if any), or null if the\n         * user is not available. This is a string having the shape\n         * `{user type}/{user id}`. For example `Practitioner/abc` or\n         * `Patient/xyz`.\n         * @alias client.getFhirUser()\n         */\n        fhirUser: string | null\n\n        /**\n         * Returns the type of the logged-in user or null. The result can be\n         * `Practitioner`, `Patient` or `RelatedPerson`.\n         * @alias client.getUserType()\n         */\n        resourceType: string | null\n    };\n\n    /**\n     * The [FhirJS](https://github.com/FHIR/fhir.js/blob/master/README.md) API.\n     * **NOTE:** This will only be available if `fhir.js` is used. Otherwise it\n     * will be `undefined`.\n     * @deprecated FhirJS integration will be removed in the next major release\n     */\n    api: fhirclient.JsonObject | undefined;\n\n    /**\n     * Refers to the refresh task while it is being performed.\n     * @see [[refresh]]\n     */\n    private _refreshTask: Promise<any> | null = null;\n\n    /**\n     * - Validates parameters\n     * - Creates an instance\n     * - If in browser, tries to connect it to FhirJS, if one is available globally\n     * - Initializes the `patient`, `user` and `encounter` APIs\n     * - Checks for rejected scopes\n     */\n    constructor(state: fhirclient.SMARTState | string, options: fhirclient.ClientOptions = {})\n    {\n        if (typeof state == \"string\") {\n            state = { serverUrl: state } as fhirclient.SMARTState\n        }\n\n        // Valid serverUrl is required!\n        assert(\n            state.serverUrl && state.serverUrl.match(/https?:\\/\\/.+/),\n            \"A \\\"serverUrl\\\" option is required and must begin with \\\"http(s)\\\"\"\n        )\n\n        Object.assign(this.options, options);\n\n        this.state = state;\n\n        const client = this;\n\n        // patient api ---------------------------------------------------------\n        this.patient = {\n            get id() { return client.getPatientId(); },\n            read: (requestOptions) => {\n                const id = this.patient.id;\n                return id ?\n                    this.request({ ...requestOptions, url: `Patient/${id}` }) :\n                    Promise.reject(new Error(\"Patient is not available\"));\n            },\n            request: (requestOptions, fhirOptions = {}) => {\n                if (this.patient.id) {\n                    return (async () => {\n                        const options = await contextualize(requestOptions, this);\n                        return this.request(options, fhirOptions);\n                    })();\n                } else {\n                    return Promise.reject(new Error(\"Patient is not available\"));\n                }\n            }\n        };\n\n        // encounter api -------------------------------------------------------\n        this.encounter = {\n            get id() { return client.getEncounterId(); },\n            read: requestOptions => {\n                const id = this.encounter.id;\n                return id ?\n                    this.request({ ...requestOptions, url: `Encounter/${id}` }) :\n                    Promise.reject(new Error(\"Encounter is not available\"));\n            }\n        };\n\n        // user api ------------------------------------------------------------\n        this.user = {\n            get fhirUser() { return client.getFhirUser(); },\n            get id() { return client.getUserId(); },\n            get resourceType() { return client.getUserType(); },\n            read: requestOptions => {\n                const fhirUser = this.user.fhirUser;\n                return fhirUser ?\n                    this.request({ ...requestOptions, url: fhirUser }) :\n                    Promise.reject(new Error(\"User is not available\"));\n            }\n        };\n\n        // fhir.js api (attached automatically in browser)\n        // ---------------------------------------------------------------------\n        if (isBrowser()) {\n            // @ts-ignore\n            this.connect(window.fhir);\n        }\n\n        this.checkScopes()\n\n        if (!this.state.expiresAt &&\n            this.state.tokenUri &&\n            this.state.tokenResponse &&\n            this.state.tokenResponse.access_token &&\n            this.state.tokenResponse.refresh_token &&\n            (this.hasGrantedScope(\"offline_access\") || this.hasGrantedScope(\"online_access\"))\n        ) {\n            console.warn(msg.noExpiresAt)\n        }\n    }\n\n    /**\n     * This method is used to make the \"link\" between the `fhirclient` and the\n     * `fhir.js`, if one is available.\n     * **Note:** This is called by the constructor. If fhir.js is available in\n     * the global scope as `fhir`, it will automatically be linked to any [[Client]]\n     * instance. You should only use this method to connect to `fhir.js` which\n     * is not global.\n     */\n    connect(fhirJs?: (options: fhirclient.JsonObject) => fhirclient.JsonObject): Client\n    {\n        if (typeof fhirJs == \"function\") {\n            const options: fhirclient.JsonObject = {\n                baseUrl: this.state.serverUrl.replace(/\\/$/, \"\")\n            };\n\n            const accessToken = this.getState(\"tokenResponse.access_token\");\n            if (accessToken) {\n                options.auth = { token: accessToken };\n            }\n            else {\n                const { username, password } = this.state;\n                if (username && password) {\n                    options.auth = {\n                        user: username,\n                        pass: password\n                    };\n                }\n            }\n            this.api = fhirJs(options);\n\n            const patientId = this.getState(\"tokenResponse.patient\");\n            if (patientId) {\n                this.patient.api = fhirJs({\n                    ...options,\n                    patient: patientId\n                });\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Checks if the given scope has been granted\n     */\n    hasGrantedScope(scope: string): boolean\n    {\n        const scopes = String(this.state.tokenResponse?.scope || \"\").trim().split(/\\s+/);\n        return scopes.indexOf(scope) > -1;\n    }\n\n    // /**\n    //  * Checks if the given scope has been requested\n    //  */\n    // hasRequestedScope(scope: string): boolean\n    // {\n    //     const scopes = String(this.state.scope || \"\").trim().split(/\\s+/);\n    //     return scopes.indexOf(scope) > -1;\n    // }\n\n    /**\n     * Compares the requested scopes (from `state.scope`) with the granted\n     * scopes (from `state.tokenResponse.scope`). Emits a warning if any of\n     * the requested scopes was not granted.\n     */\n    checkScopes()\n    {\n        const requestedScopes = String(this.state.scope || \"\").trim().split(/\\s+/).filter(Boolean);\n        const grantedScopes = String(this.state.tokenResponse?.scope || \"\").trim().split(/\\s+/);\n        const rejectedScopes = []\n        for (const requested of requestedScopes) {\n            if (grantedScopes.indexOf(requested) === -1) {\n                rejectedScopes.push(requested)\n            }\n        }\n        if (rejectedScopes.length) {\n            console.warn(msg.rejectedScopes, rejectedScopes.join('\", \"'))\n        }\n    }\n\n    /**\n     * Returns the ID of the selected patient or null. You should have requested\n     * \"launch/patient\" scope. Otherwise this will return null.\n     */\n    getPatientId(): string | null\n    {\n        const tokenResponse = this.state.tokenResponse;\n        if (tokenResponse) {\n            if (tokenResponse.patient) {\n                return tokenResponse.patient;\n            }\n            console.warn(\n                this.hasGrantedScope(\"launch\") || this.hasGrantedScope(\"launch/patient\") ?\n                msg.noPatientAvailable :\n                msg.noPatientScopes\n            );\n        } else {\n            console.warn(this.state.authorizeUri ? msg.noPatientBeforeAuth : msg.noPatientFromOpenServer);\n        }\n        return null;\n    }\n\n    /**\n     * Returns the ID of the selected encounter or null. You should have\n     * requested \"launch/encounter\" scope. Otherwise this will return null.\n     * Note that not all servers support the \"launch/encounter\" scope so this\n     * will be null if they don't.\n     */\n    getEncounterId(): string | null\n    {\n        const tokenResponse = this.state.tokenResponse;\n        if (tokenResponse) {\n            if (tokenResponse.encounter) {\n                return tokenResponse.encounter;\n            }\n            console.warn(\n                this.hasGrantedScope(\"launch\") || this.hasGrantedScope(\"launch/encounter\") ?\n                msg.noEncounterAvailable :\n                msg.noEncounterScopes\n            );\n        } else {\n            console.warn(this.state.authorizeUri ? msg.noEncounterBeforeAuth : msg.noEncounterFromOpenServer);\n        }\n        return null;\n    }\n\n    /**\n     * Returns the (decoded) id_token if any. You need to request \"openid\" and\n     * \"profile\" scopes if you need to receive an id_token (if you need to know\n     * who the logged-in user is).\n     */\n    getIdToken(): fhirclient.IDToken | null\n    {\n        const tokenResponse = this.state.tokenResponse;\n        if (tokenResponse) {\n            const idToken = tokenResponse.id_token;\n\n            // We have been authorized against this server but we don't have\n            // the id_token. This should be a scope issue.\n            if (!idToken) {\n                const hasOpenid   = this.hasGrantedScope(\"openid\");\n                const hasProfile  = this.hasGrantedScope(\"profile\");\n                const hasFhirUser = this.hasGrantedScope(\"fhirUser\");\n                console.warn(hasOpenid && (hasFhirUser || hasProfile) ? msg.noUserAvailable : msg.noUserScopes);\n                return null;\n            }\n\n            return jwtDecode(idToken) as fhirclient.IDToken;\n        }\n\n        console.warn(this.state.authorizeUri ? msg.noUserBeforeAuth : msg.noUserFromOpenServer);\n        return null;\n    }\n\n    /**\n     * Returns the profile of the logged_in user (if any). This is a string\n     * having the following shape `\"{user type}/{user id}\"`. For example:\n     * `\"Practitioner/abc\"` or `\"Patient/xyz\"`.\n     */\n    getFhirUser(): string | null\n    {\n        const idToken = this.getIdToken();\n        if (idToken) {\n            // Epic may return a full url like\n            // @see https://github.com/smart-on-fhir/client-js/issues/105\n            if (idToken.fhirUser) {\n                return idToken.fhirUser.split(\"/\").slice(-2).join(\"/\");\n            }\n            return idToken.profile\n        }\n        return null;\n    }\n\n    /**\n     * Returns the user ID or null.\n     */\n    getUserId(): string | null\n    {\n        const profile = this.getFhirUser();\n        if (profile) {\n            return profile.split(\"/\")[1];\n        }\n        return null;\n    }\n\n    /**\n     * Returns the type of the logged-in user or null. The result can be\n     * \"Practitioner\", \"Patient\" or \"RelatedPerson\".\n     */\n    getUserType(): string | null\n    {\n        const profile = this.getFhirUser();\n        if (profile) {\n            return profile.split(\"/\")[0];\n        }\n        return null;\n    }\n\n    /**\n     * Builds and returns the value of the `Authorization` header that can be\n     * sent to the FHIR server\n     */\n    getAuthorizationHeader(): string | null\n    {\n        const accessToken = this.getState(\"tokenResponse.access_token\");\n        if (accessToken) {\n            return \"Bearer \" + accessToken;\n        }\n        const { username, password } = this.state;\n        if (username && password) {\n            return \"Basic \" + btoa(username + \":\" + password);\n        }\n        return null;\n    }\n\n    /**\n     * Calls the `save` callback option (if one is provided) to persist the instance\n     * - In browsers, clients returned by smart.ready or smart.init will persist in\n     *   sessionStorage\n     * - In servers, clients returned by smart.ready or smart.init will persist in\n     *   the request session (unless configured otherwise)\n     * - Direct Client instances will not persist anywhere, unless a `save` option\n     *   is passed to the constructor\n     */\n    async saveState()\n    {\n        if (this.options.save) {\n            await this.options.save(this.state)\n        }\n    }\n\n    /**\n     * Creates a new resource in a server-assigned location\n     * @see http://hl7.org/fhir/http.html#create\n     * @param resource A FHIR resource to be created\n     * @param [requestOptions] Any options to be passed to the fetch call.\n     * Note that `method` and `body` will be ignored.\n     * @category Request\n     */\n    create<R = fhirclient.FHIR.Resource, O extends fhirclient.FetchOptions = {}>(\n        resource: fhirclient.FHIR.Resource,\n        requestOptions?: O\n    ): Promise<O[\"includeResponse\"] extends true ? fhirclient.CombinedFetchResult<R> : R>\n    {\n        return this.request({\n            ...requestOptions,\n            url: `${resource.resourceType}`,\n            method: \"POST\",\n            body: JSON.stringify(resource),\n            headers: {\n                // TODO: Do we need to alternate with \"application/json+fhir\"?\n                \"Content-Type\": \"application/json\",\n                ...(requestOptions || {}).headers\n            }\n        });\n    }\n\n    /**\n     * Creates a new current version for an existing resource or creates an\n     * initial version if no resource already exists for the given id.\n     * @see http://hl7.org/fhir/http.html#update\n     * @param resource A FHIR resource to be updated\n     * @param requestOptions Any options to be passed to the fetch call.\n     * Note that `method` and `body` will be ignored.\n     * @category Request\n     */\n    update<R = fhirclient.FHIR.Resource, O extends fhirclient.FetchOptions = {}>(\n        resource: fhirclient.FHIR.Resource,\n        requestOptions?: O\n    ): Promise<O[\"includeResponse\"] extends true ? fhirclient.CombinedFetchResult<R> : R>\n    {\n        return this.request({\n            ...requestOptions,\n            url: `${resource.resourceType}/${resource.id}`,\n            method: \"PUT\",\n            body: JSON.stringify(resource),\n            headers: {\n                // TODO: Do we need to alternate with \"application/json+fhir\"?\n                \"Content-Type\": \"application/json\",\n                ...(requestOptions || {}).headers\n            }\n        });\n    }\n\n    /**\n     * Removes an existing resource.\n     * @see http://hl7.org/fhir/http.html#delete\n     * @param url Relative URI of the FHIR resource to be deleted\n     * (format: `resourceType/id`)\n     * @param requestOptions Any options (except `method` which will be fixed\n     * to `DELETE`) to be passed to the fetch call.\n     * @category Request\n     */\n    delete<R = unknown>(url: string, requestOptions: fhirclient.FetchOptions = {}): Promise<R>\n    {\n        return this.request<R>({\n            ...requestOptions,\n            url,\n            method: \"DELETE\"\n        });\n    }\n\n    /**\n     * @param requestOptions Can be a string URL (relative to the serviceUrl),\n     * or an object which will be passed to fetch()\n     * @param fhirOptions Additional options to control the behavior\n     * @param _resolvedRefs DO NOT USE! Used internally.\n     * @category Request\n     */\n    async request<T = any>(\n        requestOptions: string|URL|fhirclient.RequestOptions,\n        fhirOptions: fhirclient.FhirOptions = {},\n        _resolvedRefs: fhirclient.JsonObject = {}\n    ): Promise<T>\n    {\n        const debugRequest = _debug.extend(\"client:request\");\n        assert(requestOptions, msg.requestNeedsArgs);\n\n        // url -----------------------------------------------------------------\n        let url: string;\n        if (typeof requestOptions == \"string\" || requestOptions instanceof URL) {\n            url = String(requestOptions);\n            requestOptions = {} as fhirclient.RequestOptions;\n        }\n        else {\n            url = String(requestOptions.url);\n        }\n\n        url = absolute(url, this.state.serverUrl);\n\n        const options = {\n            graph: fhirOptions.graph !== false,\n            flat : !!fhirOptions.flat,\n            pageLimit: fhirOptions.pageLimit ?? 1,\n            resolveReferences: (fhirOptions.resolveReferences || []) as string[],\n            useRefreshToken: fhirOptions.useRefreshToken !== false,\n            onPage: typeof fhirOptions.onPage == \"function\" ?\n                fhirOptions.onPage as (\n                    data: fhirclient.JsonObject | fhirclient.JsonObject[],\n                    references?: fhirclient.JsonObject | undefined) => any :\n                undefined\n        };\n\n        const signal = (requestOptions as RequestInit).signal || undefined;\n\n        // Refresh the access token if needed\n        const job = options.useRefreshToken ?\n            this.refreshIfNeeded({ signal }).then(() => requestOptions as fhirclient.RequestOptions) :\n            Promise.resolve(requestOptions as fhirclient.RequestOptions);\n\n        let response: Response | undefined;\n\n        return job\n\n            // Add the Authorization header now, after the access token might\n            // have been updated\n            .then(requestOptions => {\n                const authHeader = this.getAuthorizationHeader();\n                if (authHeader) {\n                    requestOptions.headers = {\n                        ...requestOptions.headers,\n                        Authorization: authHeader\n                    };\n                }\n                return requestOptions;\n            })\n            \n            // Make the request\n            .then(requestOptions => {\n                debugRequest(\n                    \"%s, options: %O, fhirOptions: %O\",\n                    url,\n                    requestOptions,\n                    options\n                );\n                return request<fhirclient.FetchResult>(url, requestOptions).then(result => {\n                    if (requestOptions.includeResponse) {\n                        response = (result as fhirclient.CombinedFetchResult).response;\n                        return (result as fhirclient.CombinedFetchResult).body;\n                    }\n                    return result;\n                });\n            })\n\n            // Handle 401 ------------------------------------------------------\n            .catch(async (error: HttpError) => {\n                if (error.status == 401) {\n\n                    // !accessToken -> not authorized -> No session. Need to launch.\n                    if (!this.getState(\"tokenResponse.access_token\")) {\n                        error.message += \"\\n\" + msg.appRequiresSMART;\n                        throw error;\n                    }\n\n                    // auto-refresh not enabled and Session expired.\n                    // Need to re-launch. Clear state to start over!\n                    if (!options.useRefreshToken) {\n                        debugRequest(msg.sessionExpiredAndNoRefresh);\n                        this.state.tokenResponse = {};\n                        await this.saveState();\n                        error.message += \"\\n\" + msg.sessionExpired;\n                        throw error;\n                    }\n\n                    // In rare cases we may have a valid access token and a refresh\n                    // token and the request might still fail with 401 just because\n                    // the access token has just been revoked.\n\n                    // otherwise -> auto-refresh failed. Session expired.\n                    // Need to re-launch. Clear state to start over!\n                    debugRequest(msg.autoRefreshFailed);\n                    this.state.tokenResponse = {};\n                    await this.saveState();\n                    error.message += \"\\n\" + msg.sessionExpired;\n                    throw error;\n                }\n                throw error;\n            })\n\n            // Handle 403 ------------------------------------------------------\n            .catch((error: HttpError) => {\n                if (error.status == 403) {\n                    debugRequest(msg.requestGot403);\n                }\n                throw error;\n            })\n\n            .then((data: any) => {\n\n                // At this point we don't know what `data` actually is!\n\n                // We might gen an empty or falsy result. If so return it as is\n                if (!data)\n                    return data;\n                \n                // Handle raw responses\n                if (typeof data == \"string\" || data instanceof Response)\n                    return data;\n\n                // Resolve References ------------------------------------------\n                return (async (_data: fhirclient.FHIR.Resource) => {\n\n                    if (_data.resourceType == \"Bundle\") {\n                        await Promise.all(((_data as fhirclient.FHIR.Bundle).entry || []).map(item => resolveRefs(\n                            item.resource,\n                            options,\n                            _resolvedRefs,\n                            this,\n                            signal\n                        )));\n                    }\n                    else {\n                        await resolveRefs(\n                            _data,\n                            options,\n                            _resolvedRefs,\n                            this,\n                            signal\n                        );\n                    }\n\n                    return _data;\n                })(data)\n\n                    // Pagination ----------------------------------------------\n                    .then(async _data => {\n                        if (_data && _data.resourceType == \"Bundle\") {\n                            const links = (_data.link || []) as fhirclient.FHIR.BundleLink[];\n\n                            if (options.flat) {\n                                _data = (_data.entry || []).map(\n                                    (entry: fhirclient.FHIR.BundleEntry) => entry.resource\n                                );\n                            }\n\n                            if (options.onPage) {\n                                await options.onPage(_data, { ..._resolvedRefs });\n                            }\n\n                            if (--options.pageLimit) {\n                                const next = links.find(l => l.relation == \"next\");\n                                _data = makeArray(_data);\n                                if (next && next.url) {\n                                    const nextPage = await this.request(\n                                        {\n                                            url: next.url,\n\n                                            // Aborting the main request (even after it is complete)\n                                            // must propagate to any child requests and abort them!\n                                            // To do so, just pass the same AbortSignal if one is\n                                            // provided.\n                                            signal\n                                        },\n                                        options,\n                                        _resolvedRefs\n                                    );\n\n                                    if (options.onPage) {\n                                        return null;\n                                    }\n\n                                    if (options.resolveReferences.length) {\n                                        Object.assign(_resolvedRefs, nextPage.references);\n                                        return _data.concat(makeArray(nextPage.data || nextPage));\n                                    }\n                                    return _data.concat(makeArray(nextPage));\n                                }\n                            }\n                        }\n                        return _data;\n                    })\n\n                    // Finalize ------------------------------------------------\n                    .then(_data => {\n                        if (options.graph) {\n                            _resolvedRefs = {};\n                        }\n                        else if (!options.onPage && options.resolveReferences.length) {\n                            return {\n                                data: _data,\n                                references: _resolvedRefs\n                            };\n                        }\n                        return _data;\n                    })\n                    .then(_data => {\n                        if ((requestOptions as fhirclient.FetchOptions).includeResponse) {\n                            return {\n                                body: _data,\n                                response\n                            }\n                        }\n                        return _data;\n                    });\n            });\n    }\n\n    /**\n     * Checks if access token and refresh token are present. If they are, and if\n     * the access token is expired or is about to expire in the next 10 seconds,\n     * calls `this.refresh()` to obtain new access token.\n     * @param requestOptions Any options to pass to the fetch call. Most of them\n     * will be overridden, bit it might still be useful for passing additional\n     * request options or an abort signal.\n     * @category Request\n     */\n    refreshIfNeeded(requestOptions: RequestInit = {}): Promise<fhirclient.SMARTState>\n    {\n        const accessToken  = this.getState(\"tokenResponse.access_token\");\n        const refreshToken = this.getState(\"tokenResponse.refresh_token\");\n        const expiresAt    = this.state.expiresAt || 0;\n\n        if (accessToken && refreshToken && expiresAt - 10 < Date.now() / 1000) {\n            return this.refresh(requestOptions);\n        }\n\n        return Promise.resolve(this.state);\n    }\n\n    /**\n     * Use the refresh token to obtain new access token. If the refresh token is\n     * expired (or this fails for any other reason) it will be deleted from the\n     * state, so that we don't enter into loops trying to re-authorize.\n     *\n     * This method is typically called internally from [[Client.request]] if\n     * certain request fails with 401.\n     *\n     * @param requestOptions Any options to pass to the fetch call. Most of them\n     * will be overridden, bit it might still be useful for passing additional\n     * request options or an abort signal.\n     * @category Request\n     */\n    refresh(requestOptions: RequestInit = {}): Promise<fhirclient.SMARTState>\n    {\n        const debugRefresh = _debug.extend(\"client:refresh\");\n        debugRefresh(\"Attempting to refresh with refresh_token...\");\n\n        const refreshToken = this.state?.tokenResponse?.refresh_token;\n        if (!refreshToken) {\n            return Promise.reject(new Error(msg.cantRefreshNoToken));\n        }\n\n        const tokenUri = this.state.tokenUri;\n        if (!tokenUri) {\n            return Promise.reject(new Error(msg.cantRefreshNoTokenUri));\n        }\n\n        const hasOfflineAccess = this.hasGrantedScope(\"offline_access\");\n        const hasOnlineAccess  = this.hasGrantedScope(\"online_access\");\n        if (!hasOfflineAccess && !hasOnlineAccess) {\n            return Promise.reject(new Error(msg.cantRefreshNoScopes));\n        }    \n\n        const refreshRequestOptions = {\n            credentials: this.options.refreshWithCredentials,\n            ...requestOptions,\n            method : \"POST\",\n            mode   : \"cors\" as RequestMode,\n            headers: {\n                ...(requestOptions.headers || {}),\n                \"content-type\": \"application/x-www-form-urlencoded\"\n            },\n            body: `grant_type=refresh_token&refresh_token=${encodeURIComponent(refreshToken)}`\n        };\n\n        // custom authorization header can be passed on manual calls\n        if (!(\"authorization\" in refreshRequestOptions.headers)) {\n            const { clientSecret, clientId } = this.state;\n            if (clientSecret) {\n                // @ts-ignore\n                refreshRequestOptions.headers.authorization = \"Basic \" + btoa(clientId + \":\" + clientSecret);\n            }\n        }\n\n        // This method is typically called internally from `request` if certain\n        // request fails with 401. However, clients will often run multiple\n        // requests in parallel which may result in multiple refresh calls.\n        // To avoid that, we keep a reference to the current refresh task (if any).\n        if (!this._refreshTask) {\n\n            this._refreshTask = request<fhirclient.TokenResponse>(tokenUri, refreshRequestOptions)\n            .then(data => {\n                assert(data.access_token, msg.gotNoAccessToken);\n                debugRefresh(\"Received new access token response %O\", data);\n                Object.assign(this.state.tokenResponse, data);\n                this.state.expiresAt = getAccessTokenExpiration(data);\n                this.checkScopes()\n                return this.state;\n            })\n            .catch((error: Error) => {\n                if (this.state?.tokenResponse?.refresh_token) {\n                    debugRefresh(\"Deleting the expired or invalid refresh token.\");\n                    delete this.state.tokenResponse.refresh_token;\n                }\n                throw error;\n            })\n            .finally(() => {\n                this._refreshTask = null;\n                return this.saveState()\n                    .catch((e) => debugRefresh(e.message))\n                    .then(() => this.state)\n            });\n        }\n\n        return this._refreshTask;\n    }\n\n    // utils -------------------------------------------------------------------\n\n    /**\n     * Groups the observations by code. Returns a map that will look like:\n     * ```js\n     * const map = client.byCodes(observations, \"code\");\n     * // map = {\n     * //     \"55284-4\": [ observation1, observation2 ],\n     * //     \"6082-2\": [ observation3 ]\n     * // }\n     * ```\n     * @param observations Array of observations\n     * @param property The name of a CodeableConcept property to group by\n     * @todo This should be deprecated and moved elsewhere. One should not have\n     * to obtain an instance of [[Client]] just to use utility functions like this.\n     * @deprecated\n     * @category Utility\n     */\n    byCode(\n        observations: fhirclient.FHIR.Observation | fhirclient.FHIR.Observation[],\n        property: string\n    ): fhirclient.ObservationMap\n    {\n        return byCode(observations, property);\n    }\n\n    /**\n     * First groups the observations by code using `byCode`. Then returns a function\n     * that accepts codes as arguments and will return a flat array of observations\n     * having that codes. Example:\n     * ```js\n     * const filter = client.byCodes(observations, \"category\");\n     * filter(\"laboratory\") // => [ observation1, observation2 ]\n     * filter(\"vital-signs\") // => [ observation3 ]\n     * filter(\"laboratory\", \"vital-signs\") // => [ observation1, observation2, observation3 ]\n     * ```\n     * @param observations Array of observations\n     * @param property The name of a CodeableConcept property to group by\n     * @todo This should be deprecated and moved elsewhere. One should not have\n     * to obtain an instance of [[Client]] just to use utility functions like this.\n     * @deprecated\n     * @category Utility\n     */\n    byCodes(\n        observations: fhirclient.FHIR.Observation | fhirclient.FHIR.Observation[],\n        property: string\n    ): (...codes: string[]) => any[]\n    {\n        return byCodes(observations, property);\n    }\n\n    /**\n     * @category Utility\n     */\n    units = units;\n\n    /**\n     * Walks through an object (or array) and returns the value found at the\n     * provided path. This function is very simple so it intentionally does not\n     * support any argument polymorphism, meaning that the path can only be a\n     * dot-separated string. If the path is invalid returns undefined.\n     * @param obj The object (or Array) to walk through\n     * @param path The path (eg. \"a.b.4.c\")\n     * @returns {*} Whatever is found in the path or undefined\n     * @todo This should be deprecated and moved elsewhere. One should not have\n     * to obtain an instance of [[Client]] just to use utility functions like this.\n     * @deprecated\n     * @category Utility\n     */\n    getPath(obj: fhirclient.JsonObject, path = \"\"): any {\n        return getPath(obj, path);\n    }\n\n    /**\n     * Returns a copy of the client state. Accepts a dot-separated path argument\n     * (same as for `getPath`) to allow for selecting specific properties.\n     * Examples:\n     * ```js\n     * client.getState(); // -> the entire state object\n     * client.getState(\"serverUrl\"); // -> the URL we are connected to\n     * client.getState(\"tokenResponse.patient\"); // -> The selected patient ID (if any)\n     * ```\n     * @param path The path (eg. \"a.b.4.c\")\n     * @returns {*} Whatever is found in the path or undefined\n     */\n    getState(path = \"\") {\n        return getPath({ ...this.state }, path);\n    }\n\n    /**\n     * Returns a promise that will be resolved with the fhir version as defined\n     * in the CapabilityStatement.\n     */\n    getFhirVersion(): Promise<string> {\n        return fetchConformanceStatement(this.state.serverUrl)\n            .then((metadata) => metadata.fhirVersion);\n    }\n\n    /**\n     * Returns a promise that will be resolved with the numeric fhir version\n     * - 2 for DSTU2\n     * - 3 for STU3\n     * - 4 for R4\n     * - 0 if the version is not known\n     */\n    getFhirRelease(): Promise<number> {\n        return this.getFhirVersion().then(v => (fhirVersions as fhirclient.JsonObject)[v] || 0);\n    }\n}\n","import { fhirclient } from \"./types\";\n\nexport {\n    getPath,\n    setPath\n} from \"./lib\"\n\n/**\n * Groups the observations by code. Returns a map that will look like:\n * ```js\n * const map = client.byCodes(observations, \"code\");\n * // map = {\n * //     \"55284-4\": [ observation1, observation2 ],\n * //     \"6082-2\": [ observation3 ]\n * // }\n * ```\n * @param observations Array of observations\n * @param property The name of a CodeableConcept property to group by\n */\nexport function byCode(\n    observations: fhirclient.FHIR.Observation | fhirclient.FHIR.Observation[],\n    property: string\n): fhirclient.ObservationMap\n{\n    const ret: fhirclient.ObservationMap = {};\n\n    function handleCodeableConcept(concept: fhirclient.FHIR.CodeableConcept, observation: fhirclient.FHIR.Observation) {\n        if (concept && Array.isArray(concept.coding)) {\n            concept.coding.forEach(({ code }) => {\n                if (code) {\n                    ret[code] = ret[code] || [] as fhirclient.FHIR.Observation[];\n                    ret[code].push(observation);\n                }\n            });\n        }\n    }\n\n    makeArray(observations).forEach(o => {\n        if (o.resourceType === \"Observation\" && o[property]) {\n            if (Array.isArray(o[property])) {\n                o[property].forEach((concept: fhirclient.FHIR.CodeableConcept) => handleCodeableConcept(concept, o));\n            } else {\n                handleCodeableConcept(o[property], o);\n            }\n        }\n    });\n\n    return ret;\n}\n\n/**\n * First groups the observations by code using `byCode`. Then returns a function\n * that accepts codes as arguments and will return a flat array of observations\n * having that codes. Example:\n * ```js\n * const filter = client.byCodes(observations, \"category\");\n * filter(\"laboratory\") // => [ observation1, observation2 ]\n * filter(\"vital-signs\") // => [ observation3 ]\n * filter(\"laboratory\", \"vital-signs\") // => [ observation1, observation2, observation3 ]\n * ```\n * @param observations Array of observations\n * @param property The name of a CodeableConcept property to group by\n */\nexport function byCodes(\n    observations: fhirclient.FHIR.Observation | fhirclient.FHIR.Observation[],\n    property: string\n): (...codes: string[]) => any[]\n{\n    const bank = byCode(observations, property);\n    return (...codes) => codes\n        .filter(code => (code + \"\") in bank)\n        .reduce(\n            (prev, code) => prev.concat(bank[code + \"\"]),\n            [] as fhirclient.FHIR.Observation[]\n        );\n}\n\n/**\n * If the argument is an array returns it as is. Otherwise puts it in an array\n * (`[arg]`) and returns the result\n * @param arg The element to test and possibly convert to array\n * @category Utility\n */\nexport function makeArray<T = any>(arg: any): T[] {\n    if (Array.isArray(arg)) {\n        return arg;\n    }\n    return [arg];\n}\n","\n// Note: the following 2 imports appear as unused but they affect how tsc is\n// generating type definitions!\nimport { fhirclient } from \"./types\";\nimport { Client } from \"./lib/Client\";\n\nimport * as util from \"./util\"\nimport * as smart from \"./lib/smart\"\n\n// In Browsers we create an adapter, get the SMART api from it and build the\n// global FHIR object\nimport BrowserAdapter from \"./lib/adapters/BrowserAdapter\";\n\nconst adapter = new BrowserAdapter();\n// const { options } = adapter.getSmartApi();\n\n// We have two kinds of browser builds - \"pure\" for new browsers and \"legacy\"\n// for old ones. In pure builds we assume that the browser supports everything\n// we need. In legacy mode, the library also acts as a polyfill. Babel will\n// automatically polyfill everything except \"fetch\", which we have to handle\n// manually.\n// @ts-ignore\nif (typeof FHIRCLIENT_PURE == \"undefined\") {\n    const fetch = require(\"cross-fetch\");\n    require(\"abortcontroller-polyfill/dist/abortcontroller-polyfill-only\");\n    if (!window.fetch) {\n        window.fetch    = fetch.default;\n        window.Headers  = fetch.Headers;\n        window.Request  = fetch.Request;\n        window.Response = fetch.Response;\n    }\n}\n\n\n\n// $lab:coverage:off$\nconst FHIR = {\n    Client,\n    SMART: {\n        authorize(options: fhirclient.AuthorizeParams | fhirclient.AuthorizeParams[]) {\n            return smart.authorize(adapter, options)\n        },\n        ready(onSuccess?: (client: Client) => any, onError?: (error: Error) => any) {\n            return smart.ready(adapter, onSuccess, onError)\n        },\n        init(options: fhirclient.AuthorizeParams | fhirclient.AuthorizeParams[]) {\n            return smart.init(adapter, options)\n        }\n    } as fhirclient.SMART,\n    util\n};\n\nexport = FHIR\n// $lab:coverage:on$\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","import { fhirclient } from \"../types\";\n\n\nexport default class HttpError extends Error\n{\n    /**\n     * The HTTP status code for this error\n     */\n    statusCode: number;\n\n    /**\n     * The HTTP status code for this error.\n     * Note that this is the same as `status`, i.e. the code is available\n     * through any of these.\n     */\n    status: number;\n\n    /**\n     * The HTTP status text corresponding to this error\n     */\n    statusText: string;\n\n    body?: any;\n\n    /**\n     * Reference to the HTTP Response object\n     */\n    response: Response;\n\n    constructor(response: Response) {\n        super(`${response.status} ${response.statusText}\\nURL: ${response.url}`);\n        this.name       = \"HttpError\";\n        this.response   = response;\n        this.statusCode = response.status;\n        this.status     = response.status;\n        this.statusText = response.statusText;\n    }\n\n    async parse()\n    {\n        if (!this.response.bodyUsed) {\n            try {\n                const type = this.response.headers.get(\"Content-Type\") || \"text/plain\";\n                if (type.match(/\\bjson\\b/i)) {\n                    this.body = await this.response.json();\n                    if (this.body.error) {\n                        this.message += \"\\n\" + this.body.error;\n                        if (this.body.error_description) {\n                            this.message += \": \" + this.body.error_description;\n                        }\n                    }\n                    else {\n                        this.message += \"\\n\\n\" + JSON.stringify(this.body, null, 4);\n                    }\n                }\n                else if (type.match(/^text\\//i)) {\n                    this.body = await this.response.text();\n                    if (this.body) {\n                        this.message += \"\\n\\n\" + this.body;\n                    }\n                }\n            } catch {\n                // ignore\n            }\n        }\n\n        return this;\n    }\n\n    toJSON() {\n        return {\n            name      : this.name,\n            statusCode: this.statusCode,\n            status    : this.status,\n            statusText: this.statusText,\n            message   : this.message\n        };\n    }\n}\n","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\nfunction log(...args) {\n\t// This hackery is required for IE8/9, where\n\t// the `console.log` function doesn't have 'apply'\n\treturn typeof console === 'object' &&\n\t\tconsole.log &&\n\t\tconsole.log(...args);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* Active `debug` instances.\n\t*/\n\tcreateDebug.instances = [];\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.enabled = createDebug.enabled(namespace);\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = selectColor(namespace);\n\t\tdebug.destroy = destroy;\n\t\tdebug.extend = extend;\n\t\t// Debug.formatArgs = formatArgs;\n\t\t// debug.rawLog = rawLog;\n\n\t\t// env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\tcreateDebug.instances.push(debug);\n\n\t\treturn debug;\n\t}\n\n\tfunction destroy() {\n\t\tconst index = createDebug.instances.indexOf(this);\n\t\tif (index !== -1) {\n\t\t\tcreateDebug.instances.splice(index, 1);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < createDebug.instances.length; i++) {\n\t\t\tconst instance = createDebug.instances[i];\n\t\t\tinstance.enabled = createDebug.enabled(instance.namespace);\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\-?\\d?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","/* global window */\nimport {\n    debug as _debug,\n    request,\n    getPath,\n    randomString,\n    getAndCache,\n    fetchConformanceStatement,\n    getAccessTokenExpiration,\n    getTargetWindow,\n    isBrowser,\n    btoa,\n    assert\n} from \".\";\nimport { Client } from \"./Client\";\nimport { SMART_KEY } from \"./settings\";\nimport { fhirclient } from \"../types\";\n\n\nconst debug = _debug.extend(\"oauth2\");\n\nexport { SMART_KEY as KEY };\n\n\n/**\n * Fetches the well-known json file from the given base URL.\n * Note that the result is cached in memory (until the page is reloaded in the\n * browser) because it might have to be re-used by the client\n * @param baseUrl The base URL of the FHIR server\n */\nexport function fetchWellKnownJson(baseUrl = \"/\", requestOptions?: RequestInit): Promise<fhirclient.WellKnownSmartConfiguration>\n{\n    const url = String(baseUrl).replace(/\\/*$/, \"/\") + \".well-known/smart-configuration\";\n    return getAndCache(url, requestOptions).catch((ex: Error) => {\n        throw new Error(`Failed to fetch the well-known json \"${url}\". ${ex.message}`);\n    });\n}\n\n/**\n * Fetch a \"WellKnownJson\" and extract the SMART endpoints from it\n */\nfunction getSecurityExtensionsFromWellKnownJson(baseUrl = \"/\", requestOptions?: RequestInit): Promise<fhirclient.OAuthSecurityExtensions>\n{\n    return fetchWellKnownJson(baseUrl, requestOptions).then(meta => {\n        assert(meta.authorization_endpoint && meta.token_endpoint, \"Invalid wellKnownJson\");\n        return {\n            registrationUri: meta.registration_endpoint  || \"\",\n            authorizeUri   : meta.authorization_endpoint,\n            tokenUri       : meta.token_endpoint\n        };\n    });\n}\n\n/**\n * Fetch a `CapabilityStatement` and extract the SMART endpoints from it\n */\nfunction getSecurityExtensionsFromConformanceStatement(baseUrl = \"/\", requestOptions?: RequestInit): Promise<fhirclient.OAuthSecurityExtensions>\n{\n    return fetchConformanceStatement(baseUrl, requestOptions).then(meta => {\n        const nsUri = \"http://fhir-registry.smarthealthit.org/StructureDefinition/oauth-uris\";\n        const extensions = ((getPath(meta || {}, \"rest.0.security.extension\") || []) as Array<fhirclient.FHIR.Extension<\"valueUri\">>)\n            .filter(e => e.url === nsUri)\n            .map(o => o.extension)[0];\n\n        const out = {\n            registrationUri : \"\",\n            authorizeUri    : \"\",\n            tokenUri        : \"\"\n        };\n\n        if (extensions) {\n            extensions.forEach(ext => {\n                if (ext.url === \"register\") {\n                    out.registrationUri = ext.valueUri;\n                }\n                if (ext.url === \"authorize\") {\n                    out.authorizeUri = ext.valueUri;\n                }\n                if (ext.url === \"token\") {\n                    out.tokenUri = ext.valueUri;\n                }\n            });\n        }\n\n        return out;\n    });\n}\n\ninterface Task {\n    controller: AbortController;\n    promise: Promise<any>;\n    complete?: boolean;\n}\n\n/**\n * This works similarly to `Promise.any()`. The tasks are objects containing a\n * request promise and it's AbortController. Returns a promise that will be\n * resolved with the return value of the first successful request, or rejected\n * with an aggregate error if all tasks fail. Any requests, other than the first\n * one that succeeds will be aborted.\n */\nfunction any(tasks: Task[]): Promise<any> {\n    const len = tasks.length;\n    const errors: Error[] = [];\n    let resolved = false;\n\n    return new Promise((resolve, reject) => {\n\n        function onSuccess(task: Task, result: any) {\n            task.complete = true;\n            if (!resolved) {\n                resolved = true;\n                tasks.forEach(t => {\n                    if (!t.complete) {\n                       t.controller.abort();\n                    }\n                });\n                resolve(result);\n            }\n        }\n\n        function onError(error: Error) {\n            if (errors.push(error) === len) {\n                reject(new Error(errors.map(e => e.message).join(\"; \")));\n            }\n        }\n\n        tasks.forEach(t => {\n            t.promise.then(result => onSuccess(t, result), onError);\n        });\n    });\n}\n\n/**\n * Given a FHIR server, returns an object with it's Oauth security endpoints\n * that we are interested in. This will try to find the info in both the\n * `CapabilityStatement` and the `.well-known/smart-configuration`. Whatever\n * Arrives first will be used and the other request will be aborted.\n * @param [baseUrl] Fhir server base URL\n * @param [env] The Adapter\n */\nexport function getSecurityExtensions(env: fhirclient.Adapter, baseUrl = \"/\"): Promise<fhirclient.OAuthSecurityExtensions>\n{\n    const AbortController = env.getAbortController();\n    const abortController1 = new AbortController();\n    const abortController2 = new AbortController();\n\n    return any([{\n        controller: abortController1,\n        promise: getSecurityExtensionsFromWellKnownJson(baseUrl, {\n            signal: abortController1.signal\n        })\n    }, {\n        controller: abortController2,\n        promise: getSecurityExtensionsFromConformanceStatement(baseUrl, {\n            signal: abortController2.signal\n        })\n    }]);\n}\n\n/**\n * Starts the SMART Launch Sequence.\n * > **IMPORTANT**:\n *   `authorize()` will end up redirecting you to the authorization server.\n *    This means that you should not add anything to the returned promise chain.\n *    Any code written directly after the authorize() call might not be executed\n *    due to that redirect!\n * @param env\n * @param [params]\n */\nexport async function authorize(\n    env: fhirclient.Adapter,\n    params: fhirclient.AuthorizeParams | fhirclient.AuthorizeParams[] = {}\n): Promise<string|void>\n{\n    const url = env.getUrl(); \n\n    // Multiple config for EHR launches ---------------------------------------\n    if (Array.isArray(params)) {\n\n        const urlISS = url.searchParams.get(\"iss\") || url.searchParams.get(\"fhirServiceUrl\");\n        assert(urlISS,'Passing in an \"iss\" url parameter is required if authorize uses multiple configurations');\n\n        // pick the right config\n        const cfg = params.find(x => {\n            if (x.issMatch) {\n                if (typeof x.issMatch === \"function\") {\n                    return !!x.issMatch(urlISS);\n                }\n                if (typeof x.issMatch === \"string\") {\n                    return x.issMatch === urlISS;\n                }\n                if (x.issMatch instanceof RegExp) {\n                    return x.issMatch.test(urlISS);\n                }\n            }\n            return false;\n        });\n\n        assert(cfg, `No configuration found matching the current \"iss\" parameter \"${urlISS}\"`);\n        return await authorize(env, cfg);\n    }\n    // ------------------------------------------------------------------------\n\n    // Obtain input\n    const {\n        clientSecret,\n        fakeTokenResponse,\n        patientId,\n        encounterId,\n        noRedirect,\n        target,\n        width,\n        height,\n        multiple\n    } = params;\n\n    let {\n        iss,\n        launch,\n        fhirServiceUrl,\n        redirectUri,\n        scope = \"\",\n        clientId,\n        completeInTarget\n    } = params;\n\n    const storage = env.getStorage();\n\n    // For these three an url param takes precedence over inline option\n    iss            = url.searchParams.get(\"iss\")            || iss;\n    fhirServiceUrl = url.searchParams.get(\"fhirServiceUrl\") || fhirServiceUrl;\n    launch         = url.searchParams.get(\"launch\")         || launch;\n\n    if (!redirectUri) {\n        redirectUri = env.relative(\".\");\n    } else if (!redirectUri.match(/^https?\\:\\/\\//)) {\n        redirectUri = env.relative(redirectUri);\n    }\n\n    const serverUrl = String(iss || fhirServiceUrl || \"\");\n\n    // Validate input\n    assert(serverUrl, 'No server url found. It must be specified as \"iss\" or as \"fhirServiceUrl\" parameter');\n\n    if (iss) {\n        debug(\"Making %s launch...\", launch ? \"EHR\" : \"standalone\");\n    }\n\n    // append launch scope if needed\n    if (launch && !scope.match(/launch/)) {\n        scope = scope ? scope + \" launch\" : \"launch\";\n    }\n\n    if (isBrowser()) {\n        const inFrame = isInFrame();\n        const inPopUp = isInPopUp();\n\n        if ((inFrame || inPopUp) && completeInTarget !== true && completeInTarget !== false) {\n            \n            // completeInTarget will default to true if authorize is called from\n            // within an iframe. This is to avoid issues when the entire app\n            // happens to be rendered in an iframe (including in some EHRs),\n            // even though that was not how the app developer's intention.\n            completeInTarget = inFrame;\n\n            // In this case we can't always make the best decision so ask devs\n            // to be explicit in their configuration.\n            console.warn(\n                'Your app is being authorized from within an iframe or popup ' +\n                'window. Please be explicit and provide a \"completeInTarget\" ' +\n                'option. Use \"true\" to complete the authorization in the '     +\n                'same window, or \"false\" to try to complete it in the parent ' +\n                'or the opener window. See http://docs.smarthealthit.org/client-js/api.html'\n            );\n        }\n    }\n\n    // If `authorize` is called, make sure we clear any previous state (in case\n    // this is a re-authorize)\n    // const oldKey = await storage.get(SMART_KEY);\n    // await storage.unset(oldKey);\n\n    // create initial state\n    const stateKey = randomString(16);\n    const state: fhirclient.SMARTState = {\n        clientId,\n        scope,\n        redirectUri,\n        serverUrl,\n        clientSecret,\n        tokenResponse: {},\n        // key: stateKey,\n        multiple,\n        completeInTarget\n    };\n\n    if (!multiple) {\n        await storage.set(SMART_KEY, stateKey);\n    }\n\n    // fakeTokenResponse to override stuff (useful in development)\n    if (fakeTokenResponse) {\n        Object.assign(state.tokenResponse, fakeTokenResponse);\n    }\n\n    // Fixed patientId (useful in development)\n    if (patientId) {\n        Object.assign(state.tokenResponse, { patient: patientId });\n    }\n\n    // Fixed encounterId (useful in development)\n    if (encounterId) {\n        Object.assign(state.tokenResponse, { encounter: encounterId });\n    }\n\n    let redirectUrl = redirectUri + \"?state=\" + encodeURIComponent(stateKey);\n\n    // bypass oauth if fhirServiceUrl is used (but iss takes precedence)\n    if (fhirServiceUrl && !iss) {\n        console.log(\"Making fake launch...\");\n        await storage.set(stateKey, state);\n        if (noRedirect) {\n            return redirectUrl;\n        }\n        return await env.redirect(redirectUrl);\n    }\n\n    // Get oauth endpoints and add them to the state\n    const extensions = await getSecurityExtensions(env, serverUrl);\n    Object.assign(state, extensions);\n    await storage.set(stateKey, state);\n\n    // If this happens to be an open server and there is no authorizeUri\n    if (!state.authorizeUri) {\n        if (noRedirect) {\n            return redirectUrl;\n        }\n        return await env.redirect(redirectUrl);\n    }\n\n    // build the redirect uri\n    const redirectParams = [\n        \"response_type=code\",\n        \"client_id=\"    + encodeURIComponent(clientId || \"\"),\n        \"scope=\"        + encodeURIComponent(scope),\n        \"redirect_uri=\" + encodeURIComponent(redirectUri),\n        \"aud=\"          + encodeURIComponent(serverUrl),\n        \"state=\"        + encodeURIComponent(stateKey)\n    ];\n\n    // also pass this in case of EHR launch\n    if (launch) {\n        redirectParams.push(\"launch=\" + encodeURIComponent(launch));\n    }\n\n    redirectUrl = state.authorizeUri + \"?\" + redirectParams.join(\"&\");\n\n    if (noRedirect) {\n        return redirectUrl;\n    }\n\n    if (target && isBrowser()) {\n        let win: Window;\n\n        win = await getTargetWindow(target, width, height);\n\n        if (win !== self) {\n            try {\n                // Also remove any old state from the target window and then\n                // transfer the current state there\n                // win.sessionStorage.removeItem(oldKey);\n                win.sessionStorage.setItem(stateKey, JSON.stringify(state));\n            } catch (ex) {\n                _debug(`Failed to modify window.sessionStorage. Perhaps it is from different origin?. Failing back to \"_self\". %s`, ex);\n                win = self;\n            }\n        }\n\n        if (win !== self) {\n            try {\n                win.location.href = redirectUrl;\n                self.addEventListener(\"message\", onMessage);\n            } catch (ex) {\n                _debug(`Failed to modify window.location. Perhaps it is from different origin?. Failing back to \"_self\". %s`, ex);\n                self.location.href = redirectUrl;\n            }\n        } else {\n            self.location.href = redirectUrl;\n        }\n\n        return;\n    }\n    else {\n        return await env.redirect(redirectUrl);\n    }\n}\n\n/**\n * Checks if called within a frame. Only works in browsers!\n * If the current window has a `parent` or `top` properties that refer to\n * another window, returns true. If trying to access `top` or `parent` throws an\n * error, returns true. Otherwise returns `false`.\n */\nexport function isInFrame() {\n    try {\n        return self !== top && parent !== self;\n    } catch (e) {\n        return true;\n    }\n}\n\n/**\n * Checks if called within another window (popup or tab). Only works in browsers!\n * To consider itself called in a new window, this function verifies that:\n * 1. `self === top` (not in frame)\n * 2. `!!opener && opener !== self` The window has an opener\n * 3. `!!window.name` The window has a `name` set\n */\nexport function isInPopUp() {\n    try {\n        return self === top &&\n               !!opener &&\n               opener !== self &&\n               !!window.name;\n    } catch (e) {\n        return false;\n    }\n}\n\n/**\n * Another window can send a \"completeAuth\" message to this one, making it to\n * navigate to e.data.url\n * @param e The message event\n */\nexport function onMessage(e: MessageEvent) {\n    if (e.data.type == \"completeAuth\" && e.origin === new URL(self.location.href).origin) {\n        window.removeEventListener(\"message\", onMessage);\n        window.location.href = e.data.url;\n    }\n}\n\nasync function cleanUpUrl(adapter: fhirclient.Adapter) {\n    const url                  = adapter.getUrl();\n    const storage              = adapter.getStorage();\n    const params               = url.searchParams;\n    const code                 = params.get(\"code\");\n    const state                = params.get(\"state\");\n\n    const from = url.href\n\n    // `code` is the flag that tells us to request an access token. We have to\n    // remove it, otherwise the page will authorize on every load!\n    if (code) {\n        params.delete(\"code\");\n        debug(\"Removed code parameter from the url.\");\n    }\n\n    // Unless we are in \"multiple\" mode, we no longer need the `state` key. It\n    // will be stored to a well known location at `sessionStorage[SMART_KEY]`.\n    if (state) {\n        const stored = await storage.get(state);\n        if (!stored.multiple) {\n            await storage.set(SMART_KEY, state);\n            params.delete(\"state\");\n            debug(\"Removed state parameter from the url.\");\n        }\n    }\n\n\n    // If the browser does not support the replaceState method for the History\n    // Web API, the \"code\" parameter cannot be removed. As a consequence, the\n    // page will (re)authorize on every load. The workaround is to reload the\n    // page to new location without those parameters (as we do for servers).\n    if (isBrowser() && window.history.replaceState) {\n        window.history.replaceState({}, \"\", url.href);\n    } else {\n        // console.log(\"redirect from\", from, \"to\", url.href)\n        return adapter.redirect(url.href)\n    }\n}\n\nasync function getAccessToken(adapter: fhirclient.Adapter, code: string, state: string): Promise<fhirclient.TokenResponse> {\n\n    assert(code, \"'code' parameter is required\");\n    assert(state, \"'state' parameter is required\");\n\n    const storage = adapter.getStorage();\n\n    let stored = (await storage.get(state)) as fhirclient.SMARTState;\n\n    debug(\"Preparing to exchange the code for access token...\");\n    const requestOptions = buildTokenRequest(code, stored);\n    debug(\"Token request options: %O\", requestOptions);\n    assert(stored.tokenUri, \"No tokenUri found for this server\")\n\n    // @ts-ignore The EHR authorization server SHALL return a JSON\n    // structure that includes an access token or a message indicating\n    // that the authorization request has been denied.\n    const tokenResponse = await request<fhirclient.TokenResponse>(stored.tokenUri, requestOptions);\n    debug(\"Token response: %O\", tokenResponse);\n    assert(tokenResponse.access_token, \"Failed to obtain access token.\");\n    return tokenResponse\n}\n\n/**\n * The completeAuth function should only be called on the page that represents\n * the redirectUri. We typically land there after a redirect from the\n * authorization server..\n */\nexport async function completeAuth(env: fhirclient.Adapter): Promise<any>\n{\n    const url                  = env.getUrl();\n    const Storage              = env.getStorage();\n    const params               = url.searchParams;\n    const code                 = params.get(\"code\");\n    const authError            = params.get(\"error\");\n    const authErrorDescription = params.get(\"error_description\");\n    const key                  = params.get(\"state\")\n\n    // Start by checking the url for `error` and `error_description` parameters.\n    // This happens when the auth server rejects our authorization attempt. In\n    // this case it has no other way to tell us what the error was, other than\n    // appending these parameters to the redirect url.\n    // From client's point of view, this is not very reliable (because we can't\n    // know how we have landed on this page - was it a redirect or was it loaded\n    // manually). However, if `completeAuth()` is being called, we can assume\n    // that the url comes from the auth server (otherwise the app won't work\n    // anyway).\n    assert(!(authError || authErrorDescription), [authError, authErrorDescription].filter(Boolean).join(\": \"));\n\n    debug(\"key: %s, code: %s\", key, code);\n\n    // key is coming from the page url so it might be empty or missing\n    assert(key, \"No 'state' parameter found. Please launch this as SMART app.\");\n\n    // Check if we have a previous state\n    let state = (await Storage.get(key)) as fhirclient.SMARTState; // console.log(state)\n\n    // If we are in a popup window or an iframe and the authorization is\n    // complete, send the location back to our opener and exit.\n    if (isBrowser() && state && !state.completeInTarget) {\n\n        const inFrame = isInFrame();\n        const inPopUp = isInPopUp();\n\n        // we are about to return to the opener/parent where completeAuth will\n        // be called again. In rare cases the opener or parent might also be\n        // a frame or popup. Then inFrame or inPopUp will be true but we still\n        // have to stop going up the chain. To guard against that weird form of\n        // recursion we pass one additional parameter to the url which we later\n        // remove.\n        if ((inFrame || inPopUp) && !url.searchParams.get(\"complete\")) {\n            url.searchParams.set(\"complete\", \"1\");\n            const { href, origin } = url;\n            if (inFrame) {\n                parent.postMessage({ type: \"completeAuth\", url: href }, origin);\n            }\n            if (inPopUp) {\n                opener.postMessage({ type: \"completeAuth\", url: href }, origin);\n                window.close();\n            }\n\n            return new Promise(() => { /* leave it pending!!! */ });\n        }\n    }\n\n    url.searchParams.delete(\"complete\");\n\n    // If the state does not exist, it means the page has been loaded directly.\n    assert(state, \"No state found! Please (re)launch the app.\");\n\n    // Assume the client has already completed a token exchange when\n    // there is no code (but we have a state) or access token is found in state\n    const authorized = !code || state.tokenResponse?.access_token;\n\n    // If we are authorized already, then this is just a reload.\n    // Otherwise, we have to complete the code flow\n    if (!authorized && state.tokenUri) {\n\n        assert(code, \"'code' url parameter is required\");\n\n        const tokenResponse = await getAccessToken(env, code, key)\n\n        // Now we need to determine when is this authorization going to expire\n        state.expiresAt = getAccessTokenExpiration(tokenResponse);\n\n        // save the tokenResponse so that we don't have to re-authorize on\n        // every page reload\n        state = { ...state, tokenResponse };\n        await Storage.set(key, state);\n        debug(\"Authorization successful!\");\n    }\n    else {\n        debug(state.tokenResponse?.access_token ? \"Already authorized\" : \"No authorization needed\");\n    }\n\n    await cleanUpUrl(env)\n\n    return getClient(env, key)\n}\n\n/**\n * Builds the token request options. Does not make the request, just\n * creates it's configuration and returns it in a Promise.\n */\nexport function buildTokenRequest(code: string, state: fhirclient.SMARTState): RequestInit\n{\n    const { redirectUri, clientSecret, tokenUri, clientId } = state;\n\n    assert(redirectUri, \"Missing state.redirectUri\");\n    assert(tokenUri, \"Missing state.tokenUri\");\n    assert(clientId, \"Missing state.clientId\");\n\n    const requestOptions: fhirclient.JsonObject = {\n        method: \"POST\",\n        headers: { \"content-type\": \"application/x-www-form-urlencoded\" },\n        body: `code=${code}&grant_type=authorization_code&redirect_uri=${\n            encodeURIComponent(redirectUri)}`\n    };\n\n    // For public apps, authentication is not possible (and thus not required),\n    // since a client with no secret cannot prove its identity when it issues a\n    // call. (The end-to-end system can still be secure because the client comes\n    // from a known, https protected endpoint specified and enforced by the\n    // redirect uri.) For confidential apps, an Authorization header using HTTP\n    // Basic authentication is required, where the username is the app’s\n    // client_id and the password is the app’s client_secret (see example).\n    if (clientSecret) {\n        requestOptions.headers.authorization = \"Basic \" + btoa(\n            clientId + \":\" + clientSecret\n        );\n        debug(\"Using state.clientSecret to construct the authorization header: %s\", requestOptions.headers.Authorization);\n    } else {\n        debug(\"No clientSecret found in state. Adding the clientId to the POST body\");\n        requestOptions.body += `&client_id=${encodeURIComponent(clientId)}`;\n    }\n\n    return requestOptions as RequestInit;\n}\n\nexport async function getClient(adapter: fhirclient.Adapter, key: string): Promise<Client>\n{\n    const storage = adapter.getStorage(); \n    const stored  = await storage.get(key);\n    assert(stored, \"No state found in storage. Please (re)launch the SMART app\")\n    return new Client(stored, {\n        save: (state: fhirclient.SMARTState) => storage.set(key, state)\n    });\n}\n\nexport async function ready(env: fhirclient.Adapter, onSuccess?: (client: Client) => any, onError?: (error: Error) => any): Promise<Client>\n{\n    let task;\n    const url    = env.getUrl();\n    const params = url.searchParams;\n    const code   = params.get(\"code\");\n    const state  = params.get(\"state\");\n\n\n    // Coming back from the auth server. Must complete the auth flow\n    if (code) {\n        task = completeAuth(env)\n    }\n\n    // Revive an app in multiple mode\n    else if (state) {\n        task = getClient(env, state)\n    }\n\n    // Revive singular app\n    else {\n        const key = await env.getStorage().get(SMART_KEY)\n        if (!key) {\n            // console.log(env.getStorage())\n        }\n        task = getClient(env, key)\n    }\n\n    if (onSuccess) {\n        task = task.then(onSuccess);\n    }\n\n    if (onError) {\n        task = task.catch(onError);\n    }\n\n    return task;\n}\n\n/**\n * This function can be used when you want to handle everything in one page\n * (no launch endpoint needed). You can think of it as if it does:\n * ```js\n * authorize(options).then(ready)\n * ```\n *\n * **Be careful with init()!** There are some details you need to be aware of:\n *\n * 1. It will only work if your launch_uri is the same as your redirect_uri.\n *    While this should be valid, we can’t promise that every EHR will allow you\n *    to register client with such settings.\n * 2. Internally, `init()` will be called twice. First it will redirect to the\n *    EHR, then the EHR will redirect back to the page where init() will be\n *    called again to complete the authorization. This is generally fine,\n *    because the returned promise will only be resolved once, after the second\n *    execution, but please also consider the following:\n *    - You should wrap all your app’s code in a function that is only executed\n *      after `init()` resolves!\n *    - Since the page will be loaded twice, you must be careful if your code\n *      has global side effects that can persist between page reloads\n *      (for example writing to localStorage).\n * 3. For standalone launch, only use init in combination with offline_access\n *    scope. Once the access_token expires, if you don’t have a refresh_token\n *    there is no way to re-authorize properly. We detect that and delete the\n *    expired access token, but it still means that the user will have to\n *    refresh the page twice to re-authorize.\n * @param env The adapter\n * @param options The authorize options\n */\nexport async function init(env: fhirclient.Adapter, options: fhirclient.AuthorizeParams | fhirclient.AuthorizeParams[]): Promise<Client|never>\n{\n    const url   = env.getUrl();\n    const code  = url.searchParams.get(\"code\");\n    const state = url.searchParams.get(\"state\");\n\n    // if `code` and `state` params are present we need to complete the auth flow\n    if (code && state) {\n        return completeAuth(env);\n    }\n\n    // Check for existing client state. If state is found, it means a client\n    // instance have already been created in this session and we should try to\n    // \"revive\" it.\n    const storage = env.getStorage();\n    const key     = state || await storage.get(SMART_KEY);\n    const cached  = await storage.get(key);\n    if (cached) {\n        return new Client(cached, {\n            save: (state: fhirclient.SMARTState) => storage.set(key, state)\n        })\n    }\n\n    // Otherwise try to launch\n    return authorize(env, options).then(() => {\n        // `init` promises a Client but that cannot happen in this case. The\n        // browser will be redirected (unload the page and be redirected back\n        // to it later and the same init function will be called again). On\n        // success, authorize will resolve with the redirect url but we don't\n        // want to return that from this promise chain because it is not a\n        // Client instance. At the same time, if authorize fails, we do want to\n        // pass the error to those waiting for a client instance.\n        return new Promise(() => { /* leave it pending!!! */ });\n    });\n}\n","import { ready, authorize, init } from \"../smart\";\nimport { Client } from \"../Client\";\nimport BrowserStorage from \"../storage/BrowserStorage\";\nimport { fhirclient } from \"../../types\";\n\n/**\n * Browser Adapter\n */\nexport default class BrowserAdapter implements fhirclient.Adapter\n{\n    /**\n     * Stores the URL instance associated with this adapter\n     */\n    private _url: URL | null = null;\n\n    /**\n     * Holds the Storage instance associated with this instance\n     */\n    private _storage: fhirclient.Storage | null = null;\n\n    /**\n     * Environment-specific options\n     */\n    options: fhirclient.BrowserFHIRSettings;\n\n    /**\n     * @param options Environment-specific options\n     */\n    constructor(options: fhirclient.BrowserFHIRSettings = {})\n    {\n        this.options = {\n            // Replaces the browser's current URL\n            // using window.history.replaceState API or by reloading.\n            replaceBrowserHistory: true,\n\n            // Do we want to send cookies while making a request to the token\n            // endpoint in order to obtain new access token using existing\n            // refresh token. In rare cases the auth server might require the\n            // client to send cookies along with those requests. In this case\n            // developers will have to change this before initializing the app\n            // like so:\n            // `FHIR.oauth2.settings.refreshTokenWithCredentials = \"include\";`\n            // or\n            // `FHIR.oauth2.settings.refreshTokenWithCredentials = \"same-origin\";`\n            // Can be one of:\n            // \"include\"     - always send cookies\n            // \"same-origin\" - only send cookies if we are on the same domain (default)\n            // \"omit\"        - do not send cookies\n            refreshTokenWithCredentials: \"same-origin\",\n\n            ...options\n        };\n    }\n\n    /**\n     * Given a relative path, returns an absolute url using the instance base URL\n     */\n    relative(path: string): string\n    {\n        return new URL(path, this.getUrl().href).href;\n    }\n\n    /**\n     * In browsers we need to be able to (dynamically) check if fhir.js is\n     * included in the page. If it is, it should have created a \"fhir\" variable\n     * in the global scope.\n     */\n    get fhir()\n    {\n        // @ts-ignore\n        return typeof fhir === \"function\" ? fhir : null;\n    }\n\n    /**\n     * Given the current environment, this method must return the current url\n     * as URL instance\n     */\n    getUrl(): URL\n    {\n        if (!this._url) {\n            this._url = new URL(location + \"\");\n        }\n        return this._url;\n    }\n\n    /**\n     * Given the current environment, this method must redirect to the given\n     * path\n     */\n    redirect(to: string): void\n    {\n        location.href = to;\n    }\n\n    /**\n     * Returns a BrowserStorage object which is just a wrapper around\n     * sessionStorage\n     */\n    getStorage(): BrowserStorage\n    {\n        if (!this._storage) {\n            this._storage = new BrowserStorage();\n        }\n        return this._storage;\n    }\n\n    /**\n     * Returns a reference to the AbortController constructor. In browsers,\n     * AbortController will always be available as global (native or polyfilled)\n     */\n    getAbortController()\n    {\n        return AbortController;\n    }\n\n    // /**\n    //  * Creates and returns adapter-aware SMART api. Not that while the shape of\n    //  * the returned object is well known, the arguments to this function are not.\n    //  * Those who override this method are free to require any environment-specific\n    //  * arguments. For example in node we will need a request, a response and\n    //  * optionally a storage or storage factory function.\n    //  */\n    // getSmartApi(): fhirclient.SMART\n    // {\n    //     return {\n    //         ready    : (...args: any[]) => ready(this, ...args),\n    //         authorize: options => authorize(this, options),\n    //         init     : options => init(this, options),\n    //         client   : (state: string | fhirclient.SMARTState) => {\n    //             if (typeof state === \"string\") {\n    //                 state = { serverUrl: state }\n    //             }\n    //             const client = new Client(state, {\n    //                 refreshWithCredentials: this.options.refreshTokenWithCredentials\n    //             })\n    //             return client\n    //         },\n    //         options  : this.options\n    //     };\n    // }\n}\n","import { fhirclient } from \"../../types\";\n\n\nexport default class Storage\n{\n    /**\n     * Gets the value at `key`. Returns a promise that will be resolved\n     * with that value (or undefined for missing keys).\n     */\n    async get(key: string): Promise<any>\n    {\n        const value = sessionStorage[key];\n        if (value) {\n            return JSON.parse(value);\n        }\n        return undefined;\n    }\n\n    /**\n     * Sets the `value` on `key` and returns a promise that will be resolved\n     * with the value that was set.\n     */\n    async set(key: string, value: any): Promise<any>\n    {\n        sessionStorage[key] = JSON.stringify(value);\n        return value;\n    }\n\n    /**\n     * Deletes the value at `key`. Returns a promise that will be resolved\n     * with true if the key was deleted or with false if it was not (eg. if\n     * did not exist).\n     */\n    async unset(key: string): Promise<boolean>\n    {\n        if (key in sessionStorage) {\n            delete sessionStorage[key];\n            return true;\n        }\n        return false;\n    }\n\n    async clear(): Promise<void>\n    {\n        return sessionStorage.clear()\n    }\n\n    async save(data: fhirclient.JsonObject)\n    {\n        for(const key of Object.keys(data)) {\n            await this.set(key, data[key])\n        }\n        return data\n    }\n}\n"],"sourceRoot":""}