{"version":3,"sources":["webpack://FHIR/webpack/bootstrap","webpack://FHIR/./src/settings.ts","webpack://FHIR/./src/lib.ts","webpack://FHIR/./src/Client.ts","webpack://FHIR/./src/entry/browser.ts","webpack://FHIR/./src/adapters/BrowserAdapter.ts","webpack://FHIR/./src/smart.ts","webpack://FHIR/(webpack)/buildin/global.js","webpack://FHIR/./src/HttpError.ts","webpack://FHIR/./node_modules/debug/src/browser.js","webpack://FHIR/./node_modules/process/browser.js","webpack://FHIR/./node_modules/debug/src/common.js","webpack://FHIR/./node_modules/debug/node_modules/ms/index.js","webpack://FHIR/./src/storage/BrowserStorage.ts","webpack://FHIR/./src/util.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","patientCompartment","fhirVersions","patientParams","SMART_KEY","debug","fetch","window","_debug","cache","ensureNumerical","code","Error","async","checkResponse","resp","ok","error","parse","responseToJSON","text","then","length","JSON","request","url","requestOptions","includeResponse","options","headers","accept","res","type","match","body","status","location","method","response","undefined","getAndCache","force","Promise","resolve","getPath","obj","path","trim","segments","split","result","shift","Array","isArray","map","join","makeArray","arg","isBrowser","atob","str","global","Buffer","from","toString","jwtDecode","token","payload","byCode","observations","ret","handleCodeableConcept","concept","observation","coding","forEach","push","resourceType","units","any","pq","baseUrl","String","replace","catch","ex","createEmpty","reduce","out","idx","arr","strLength","charSet","len","charAt","Math","floor","random","btoa","tokenResponse","now","Date","expires_in","access_token","tokenBody","exp","bank","codes","filter","prev","concat","conformance","meta","find","searchParam","x","target","width","height","self","parent","top","targetWindow","open","e","screen","winOrFrame","frames","Response","extend","resolveRef","graph","client","signal","node","all","Boolean","item","ref","reference","refId","getRef","sub","indexOf","setPath","resolveRefs","fhirOptions","paths","resolveReferences","groups","task","keys","sort","group","msg","noPatientBeforeAuth","noPatientFromOpenServer","noPatientScopes","noPatientAvailable","noEncounterBeforeAuth","noEncounterFromOpenServer","noEncounterScopes","noEncounterAvailable","noUserBeforeAuth","noUserFromOpenServer","noUserScopes","noUserAvailable","requestNeedsArgs","appRequiresSMART","sessionExpiredAndNoRefresh","sessionExpired","autoRefreshFailed","requestGot403","cantRefreshNoToken","cantRefreshNoTokenUri","cantRefreshNoScopes","gotNoAccessToken","rejectedScopes","noExpiresAt","state","refreshWithCredentials","_refreshTask","serverUrl","assign","this","patient","getPatientId","read","id","reject","base","absolute","contextualURL","_url","pathname","pop","fetchConformanceStatement","getPatientParam","searchParams","set","href","URL","contextualize","encounter","getEncounterId","user","getFhirUser","getUserId","getUserType","fhirUser","connect","fhir","checkScopes","expiresAt","tokenUri","refresh_token","hasGrantedScope","console","warn","fhirJs","accessToken","getState","auth","username","password","pass","api","patientId","scope","requestedScopes","grantedScopes","requested","authorizeUri","idToken","id_token","hasOpenid","hasProfile","hasFhirUser","getIdToken","profile","save","resource","stringify","_resolvedRefs","debugRequest","flat","pageLimit","useRefreshToken","onPage","refreshIfNeeded","authHeader","getAuthorizationHeader","Authorization","message","saveState","data","_data","entry","links","link","next","relation","nextPage","references","refreshToken","refresh","debugRefresh","hasOfflineAccess","hasOnlineAccess","refreshRequestOptions","credentials","encodeURIComponent","clientSecret","clientId","authorization","getAccessTokenExpiration","finally","byCodes","metadata","fhirVersion","getFhirVersion","v","adapter","ready","authorize","init","getSmartApi","FHIR","AbortController","oauth2","settings","util","_storage","replaceBrowserHistory","fullSessionStorageSupport","refreshTokenWithCredentials","getUrl","to","args","Client","fetchWellKnownJson","getSecurityExtensionsFromWellKnownJson","authorization_endpoint","token_endpoint","registrationUri","registration_endpoint","getSecurityExtensionsFromConformanceStatement","extensions","extension","ext","valueUri","tasks","errors","resolved","onError","promise","complete","controller","abort","onSuccess","getSecurityExtensions","env","getAbortController","abortController1","abortController2","params","urlISS","cfg","issMatch","RegExp","test","redirect_uri","fakeTokenResponse","encounterId","client_id","noRedirect","iss","launch","fhirServiceUrl","redirectUri","completeInTarget","storage","getStorage","relative","inFrame","isInFrame","inPopUp","isInPopUp","oldKey","unset","stateKey","randomString","redirectUrl","redirect","redirectParams","win","getTargetWindow","sessionStorage","removeItem","setItem","addEventListener","onMessage","opener","origin","removeEventListener","completeAuth","Storage","authError","authErrorDescription","postMessage","close","delete","hasState","has","history","replaceState","buildTokenRequest","cached","g","Function","HttpError","super","statusText","statusCode","bodyUsed","json","error_description","log","formatArgs","useColors","namespace","humanize","diff","color","splice","index","lastC","namespaces","load","getItem","process","DEBUG","__nwjs","navigator","userAgent","toLowerCase","document","documentElement","style","WebkitAppearance","firebug","exception","table","parseInt","$1","localStorage","localstorage","colors","formatters","j","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","setTimeout","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","timeout","run","marker","runClearTimeout","Item","array","noop","nextTick","arguments","apply","title","browser","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","selectColor","hash","charCodeAt","createDebug","abs","prevTime","enabled","curr","Number","ms","coerce","unshift","format","formatter","val","destroy","instances","delimiter","newDebug","toNamespace","regexp","substring","default","stack","disable","names","skips","enable","substr","instance","h","plural","msAbs","isPlural","round","exec","parseFloat","isNaN","long","fmtLong","fmtShort","clear"],"mappings":"wBACE,IAAIA,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUC,QAGnC,IAAIC,EAASJ,EAAiBE,GAAY,CACzCG,EAAGH,EACHI,GAAG,EACHH,QAAS,IAUV,OANAI,EAAQL,GAAUM,KAAKJ,EAAOD,QAASC,EAAQA,EAAOD,QAASF,GAG/DG,EAAOE,GAAI,EAGJF,EAAOD,QA0Df,OArDAF,EAAoBQ,EAAIF,EAGxBN,EAAoBS,EAAIV,EAGxBC,EAAoBU,EAAI,SAASR,EAASS,EAAMC,GAC3CZ,EAAoBa,EAAEX,EAASS,IAClCG,OAAOC,eAAeb,EAASS,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEZ,EAAoBkB,EAAI,SAAShB,GACX,oBAAXiB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAeb,EAASiB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAeb,EAAS,aAAc,CAAEmB,OAAO,KAQvDrB,EAAoBsB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQrB,EAAoBqB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFA1B,EAAoBkB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOrB,EAAoBU,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRzB,EAAoB6B,EAAI,SAAS1B,GAChC,IAAIS,EAAST,GAAUA,EAAOqB,WAC7B,WAAwB,OAAOrB,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAH,EAAoBU,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRZ,EAAoBa,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG/B,EAAoBkC,EAAI,GAIjBlC,EAAoBA,EAAoBmC,EAAI,G,uJC/ExC,EAAAC,mBAAqB,CAC9B,UACA,eACA,qBACA,cACA,sBACA,aACA,QACA,WACA,gBACA,WACA,WACA,aACA,QACA,gBACA,qBACA,gBACA,uBACA,cACA,YACA,UACA,WACA,6BACA,8BACA,gBACA,gBACA,mBACA,qBACA,kBACA,mBACA,mBACA,oBACA,qBACA,YACA,oBACA,gBACA,uBACA,sBACA,OACA,OACA,QACA,kBACA,yBACA,eACA,eACA,yBACA,6BACA,UACA,OACA,gBACA,QACA,2BACA,qBACA,kBACA,oBACA,sBACA,oBACA,iBACA,cACA,QACA,UACA,SACA,YACA,mBACA,aACA,wBACA,kBACA,gBACA,eACA,kBACA,iBACA,WACA,iBACA,WACA,iBACA,gBACA,sBAMS,EAAAC,aAAe,CACxB,QAAS,EACT,QAAS,EACT,QAAS,EACT,QAAS,EACT,QAAS,EACT,QAAS,EACT,QAAS,EACT,QAAS,EACT,QAAS,EACT,QAAS,EACT,QAAS,EACT,QAAS,EACT,QAAS,EACT,QAAS,EACT,QAAS,GAOA,EAAAC,cAAgB,CACzB,UACA,UACA,YACA,SACA,QACA,eAMS,EAAAC,UAAY,a,yXClHzB,aACA,OAEMC,EAAQ,EAAQ,IAIhB,MAAEC,GAAmDC,OAGrDC,EAAaH,EAAM,QACN,EAAAA,MAAA,EAKnB,MAAMI,EAA+B,GAkCrC,SAASC,GAAgB,MAAExB,EAAF,KAASyB,IAC9B,GAAqB,iBAAVzB,EACP,MAAM,IAAI0B,MAAM,+BAAiC1B,EAAQ,IAAMyB,GAOhEE,eAAeC,EAAcC,GAChC,IAAKA,EAAKC,GAAI,CACV,MAAMC,EAAQ,IAAI,UAAUF,GAE5B,YADME,EAAMC,QACND,EAEV,OAAOF,EAQX,SAAgBI,EAAeJ,GAC3B,OAAOA,EAAKK,OAAOC,KAAKD,GAAQA,EAAKE,OAASC,KAAKL,MAAME,GAAQ,IAarE,SAAgBI,EACZC,EACAC,EAA0C,IAG1C,MAAM,gBAAEC,KAAoBC,GAAYF,EACxC,OAAOpB,EAAMmB,EAAK,CACdrC,KAAM,UACHwC,EACHC,QAAS,CACLC,OAAQ,sB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","file":"fhir-client.pure.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","/**\n * Combined list of FHIR resource types accepting patient parameter in FHIR R2-R4\n */\nexport const patientCompartment = [\n    \"Account\",\n    \"AdverseEvent\",\n    \"AllergyIntolerance\",\n    \"Appointment\",\n    \"AppointmentResponse\",\n    \"AuditEvent\",\n    \"Basic\",\n    \"BodySite\",\n    \"BodyStructure\",\n    \"CarePlan\",\n    \"CareTeam\",\n    \"ChargeItem\",\n    \"Claim\",\n    \"ClaimResponse\",\n    \"ClinicalImpression\",\n    \"Communication\",\n    \"CommunicationRequest\",\n    \"Composition\",\n    \"Condition\",\n    \"Consent\",\n    \"Coverage\",\n    \"CoverageEligibilityRequest\",\n    \"CoverageEligibilityResponse\",\n    \"DetectedIssue\",\n    \"DeviceRequest\",\n    \"DeviceUseRequest\",\n    \"DeviceUseStatement\",\n    \"DiagnosticOrder\",\n    \"DiagnosticReport\",\n    \"DocumentManifest\",\n    \"DocumentReference\",\n    \"EligibilityRequest\",\n    \"Encounter\",\n    \"EnrollmentRequest\",\n    \"EpisodeOfCare\",\n    \"ExplanationOfBenefit\",\n    \"FamilyMemberHistory\",\n    \"Flag\",\n    \"Goal\",\n    \"Group\",\n    \"ImagingManifest\",\n    \"ImagingObjectSelection\",\n    \"ImagingStudy\",\n    \"Immunization\",\n    \"ImmunizationEvaluation\",\n    \"ImmunizationRecommendation\",\n    \"Invoice\",\n    \"List\",\n    \"MeasureReport\",\n    \"Media\",\n    \"MedicationAdministration\",\n    \"MedicationDispense\",\n    \"MedicationOrder\",\n    \"MedicationRequest\",\n    \"MedicationStatement\",\n    \"MolecularSequence\",\n    \"NutritionOrder\",\n    \"Observation\",\n    \"Order\",\n    \"Patient\",\n    \"Person\",\n    \"Procedure\",\n    \"ProcedureRequest\",\n    \"Provenance\",\n    \"QuestionnaireResponse\",\n    \"ReferralRequest\",\n    \"RelatedPerson\",\n    \"RequestGroup\",\n    \"ResearchSubject\",\n    \"RiskAssessment\",\n    \"Schedule\",\n    \"ServiceRequest\",\n    \"Specimen\",\n    \"SupplyDelivery\",\n    \"SupplyRequest\",\n    \"VisionPrescription\"\n];\n\n/**\n * Map of FHIR releases and their abstract version as number\n */\nexport const fhirVersions = {\n    \"0.4.0\": 2,\n    \"0.5.0\": 2,\n    \"1.0.0\": 2,\n    \"1.0.1\": 2,\n    \"1.0.2\": 2,\n    \"1.1.0\": 3,\n    \"1.4.0\": 3,\n    \"1.6.0\": 3,\n    \"1.8.0\": 3,\n    \"3.0.0\": 3,\n    \"3.0.1\": 3,\n    \"3.3.0\": 4,\n    \"3.5.0\": 4,\n    \"4.0.0\": 4,\n    \"4.0.1\": 4\n};\n\n/**\n * Combined (FHIR R2-R4) list of search parameters that can be used to scope\n * a request by patient ID.\n */\nexport const patientParams = [\n    \"patient\",\n    \"subject\",\n    \"requester\",\n    \"member\",\n    \"actor\",\n    \"beneficiary\"\n];\n\n/**\n * The name of the sessionStorage entry that contains the current key\n */\nexport const SMART_KEY = \"SMART_KEY\";\n","/*\n * This file contains some shared functions. They are used by other modules, but\n * are defined here so that tests can import this library and test them.\n */\n\nimport HttpError from \"./HttpError\";\nimport { patientParams } from \"./settings\";\nimport { fhirclient } from \"./types\";\nconst debug = require(\"debug\");\n\n// $lab:coverage:off$\n// @ts-ignore\nconst { fetch } = typeof FHIRCLIENT_PURE !== \"undefined\" ? window : require(\"cross-fetch\");\n// $lab:coverage:on$\n\nconst _debug     = debug(\"FHIR\");\nexport { _debug as debug };\n\n/**\n * The cache for the `getAndCache` function\n */\nconst cache: fhirclient.JsonObject = {};\n\n/**\n * A namespace with functions for converting between different measurement units\n */\nexport const units = {\n    cm({ code, value }: fhirclient.CodeValue) {\n        ensureNumerical({ code, value });\n        if (code == \"cm\"     ) return value;\n        if (code == \"m\"      ) return value *   100;\n        if (code == \"in\"     ) return value *  2.54;\n        if (code == \"[in_us]\") return value *  2.54;\n        if (code == \"[in_i]\" ) return value *  2.54;\n        if (code == \"ft\"     ) return value * 30.48;\n        if (code == \"[ft_us]\") return value * 30.48;\n        throw new Error(\"Unrecognized length unit: \" + code);\n    },\n    kg({ code, value }: fhirclient.CodeValue){\n        ensureNumerical({ code, value });\n        if (code == \"kg\"    ) return value;\n        if (code == \"g\"     ) return value / 1000;\n        if (code.match(/lb/)) return value / 2.20462;\n        if (code.match(/oz/)) return value / 35.274;\n        throw new Error(\"Unrecognized weight unit: \" + code);\n    },\n    any(pq: fhirclient.CodeValue){\n        ensureNumerical(pq);\n        return pq.value;\n    }\n};\n\n/**\n * Assertion function to guard arguments for `units` functions\n */\nfunction ensureNumerical({ value, code }: fhirclient.CodeValue) {\n    if (typeof value !== \"number\") {\n        throw new Error(\"Found a non-numerical unit: \" + value + \" \" + code);\n    }\n}\n\n/**\n * Used in fetch Promise chains to reject if the \"ok\" property is not true\n */\nexport async function checkResponse(resp: Response): Promise<Response> {\n    if (!resp.ok) {\n        const error = new HttpError(resp);\n        await error.parse();\n        throw error;\n    }\n    return resp;\n}\n\n/**\n * Used in fetch Promise chains to return the JSON version of the response.\n * Note that `resp.json()` will throw on empty body so we use resp.text()\n * instead.\n */\nexport function responseToJSON(resp: Response): Promise<object|string> {\n    return resp.text().then(text => text.length ? JSON.parse(text) : \"\");\n}\n\n/**\n * This is our built-in request function. It does a few things by default\n * (unless told otherwise):\n * - Makes CORS requests\n * - Sets accept header to \"application/json\"\n * - Handles errors\n * - If the response is json return the json object\n * - If the response is text return the result text\n * - Otherwise return the response object on which we call stuff like `.blob()`\n */\nexport function request<T = fhirclient.FetchResult>(\n    url: string | Request,\n    requestOptions: fhirclient.FetchOptions = {}\n): Promise<T>\n{\n    const { includeResponse, ...options } = requestOptions;\n    return fetch(url, {\n        mode: \"cors\",\n        ...options,\n        headers: {\n            accept: \"application/json\",\n            ...options.headers\n        }\n    })\n    .then(checkResponse)\n    .then((res: Response) => {\n        const type = res.headers.get(\"Content-Type\") + \"\";\n        if (type.match(/\\bjson\\b/i)) {\n            return responseToJSON(res).then(body => ({ res, body }));\n        }\n        if (type.match(/^text\\//i)) {\n            return res.text().then(body => ({ res, body }));\n        }\n        return { res };\n    })\n    .then(({res, body}: {res:Response, body?:fhirclient.JsonObject|string}) => {\n\n        // Some servers will reply after CREATE with json content type but with\n        // empty body. In this case check if a location header is received and\n        // fetch that to use it as the final result.\n        if (!body && res.status == 201) {\n            const location = res.headers.get(\"location\");\n            if (location) {\n                return request(location, { ...options, method: \"GET\", body: null, includeResponse });\n            }\n        }\n\n        if (includeResponse) {\n            return { body, response: res };\n        }\n\n        // For any non-text and non-json response return the Response object.\n        // This to let users decide if they want to call text(), blob() or\n        // something else on it\n        if (body === undefined) {\n            return res;\n        }\n\n        // Otherwise just return the parsed body (can also be \"\" or null)\n        return body;\n    });\n}\n\n/**\n * Makes a request using `fetch` and stores the result in internal memory cache.\n * The cache is cleared when the page is unloaded.\n * @param url The URL to request\n * @param requestOptions Request options\n * @param force If true, reload from source and update the cache, even if it has\n * already been cached.\n */\nexport function getAndCache(url: string, requestOptions?: RequestInit, force: boolean = process.env.NODE_ENV === \"test\"): Promise<any> {\n    if (force || !cache[url]) {\n        cache[url] = request(url, requestOptions);\n        return cache[url];\n    }\n    return Promise.resolve(cache[url]);\n}\n\n/**\n * Fetches the conformance statement from the given base URL.\n * Note that the result is cached in memory (until the page is reloaded in the\n * browser) because it might have to be re-used by the client\n * @param baseUrl The base URL of the FHIR server\n * @param [requestOptions] Any options passed to the fetch call\n */\nexport function fetchConformanceStatement(baseUrl = \"/\", requestOptions?: RequestInit): Promise<fhirclient.FHIR.CapabilityStatement>\n{\n    const url = String(baseUrl).replace(/\\/*$/, \"/\") + \"metadata\";\n    return getAndCache(url, requestOptions).catch((ex: Error) => {\n        throw new Error(\n            `Failed to fetch the conformance statement from \"${url}\". ${ex}`\n        );\n    });\n}\n\n\n/**\n * Walks through an object (or array) and returns the value found at the\n * provided path. This function is very simple so it intentionally does not\n * support any argument polymorphism, meaning that the path can only be a\n * dot-separated string. If the path is invalid returns undefined.\n * @param obj The object (or Array) to walk through\n * @param path The path (eg. \"a.b.4.c\")\n * @returns {*} Whatever is found in the path or undefined\n */\nexport function getPath(obj: fhirclient.JsonObject, path = \"\"): any {\n    path = path.trim();\n    if (!path) {\n        return obj;\n    }\n\n    let segments = path.split(\".\");\n    let result = obj;\n\n    while (result && segments.length) {\n        const key = segments.shift();\n        if (!key && Array.isArray(result)) {\n            return result.map(o => getPath(o, segments.join(\".\")));\n        } else {\n            result = result[key as string];\n        }\n    }\n\n    return result;\n}\n\n/**\n * Like getPath, but if the node is found, its value is set to @value\n * @param obj The object (or Array) to walk through\n * @param path The path (eg. \"a.b.4.c\")\n * @param value The value to set\n * @param createEmpty If true, create missing intermediate objects or arrays\n * @returns The modified object\n */\nexport function setPath(obj: fhirclient.JsonObject, path: string, value: any, createEmpty = false): fhirclient.JsonObject {\n    path.trim().split(\".\").reduce(\n        (out, key, idx, arr) => {\n            if (out && idx === arr.length - 1) {\n                out[key] = value;\n            }\n            else {\n                if (out && out[key] === undefined && createEmpty) {\n                    out[key] = arr[idx + 1].match(/^[0-9]+$/) ? [] : {};\n                }\n                return out ? out[key] : undefined;\n            }\n        },\n        obj\n    );\n    return obj;\n}\n\n/**\n * If the argument is an array returns it as is. Otherwise puts it in an array\n * (`[arg]`) and returns the result\n * @param arg The element to test and possibly convert to array\n * @category Utility\n */\nexport function makeArray<T = any>(arg: any): T[] {\n    if (Array.isArray(arg)) {\n        return arg;\n    }\n    return [arg];\n}\n\n/**\n * Given a path, converts it to absolute url based on the `baseUrl`. If baseUrl\n * is not provided, the result would be a rooted path (one that starts with `/`).\n * @param path The path to convert\n * @param baseUrl The base URL\n */\nexport function absolute(path: string, baseUrl?: string): string\n{\n    if (path.match(/^http/)) return path;\n    if (path.match(/^urn/)) return path;\n    return String(baseUrl || \"\").replace(/\\/+$/, \"\") + \"/\" + path.replace(/^\\/+/, \"\");\n}\n\n/**\n * Generates random strings. By default this returns random 8 characters long\n * alphanumeric strings.\n * @param strLength The length of the output string. Defaults to 8.\n * @param charSet A string containing all the possible characters.\n *     Defaults to all the upper and lower-case letters plus digits.\n * @category Utility\n */\nexport function randomString(\n    strLength = 8,\n    charSet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"\n): string\n{\n    const result = [];\n    const len = charSet.length;\n    while (strLength--) {\n        result.push(charSet.charAt(Math.floor(Math.random() * len)));\n    }\n    return result.join(\"\");\n}\n\nexport function isBrowser()\n{\n    return typeof window === \"object\";\n}\n\n/**\n * Base64 to ASCII\n */\nexport function atob(str: string): string\n{\n     return isBrowser() ?\n\n        // Browsers have global atob method\n        window.atob(str) :\n        \n        // \"global.\" helps Webpack understand that it doesn't have to\n        // include the Buffer code in the bundle\n        global.Buffer.from(str, \"base64\").toString(\"ascii\");\n}\n\n/**\n * ASCII to Base64\n */\nexport function btoa(str: string): string\n{\n    return isBrowser() ?\n\n        // Browsers have global btoa method\n        window.btoa(str) :\n        \n        // \"global.\" helps Webpack understand that it doesn't have to\n        // include the Buffer code in the bundle\n        global.Buffer.from(str).toString(\"base64\");\n}\n\n/**\n * Decodes a JWT token and returns it's body.\n * @param token The token to read\n * @param env An `Adapter` or any other object that has an `atob` method\n * @category Utility\n */\nexport function jwtDecode(token: string): fhirclient.JsonObject | null\n{\n    const payload = token.split(\".\")[1];\n    return payload ? JSON.parse(atob(payload)) : null;\n}\n\n/**\n * Given a token response, computes and returns the expiresAt timestamp.\n * Note that this should only be used immediately after an access token is\n * received, otherwise the computed timestamp will be incorrect.\n * @param tokenResponse \n * @param env \n */\nexport function getAccessTokenExpiration(tokenResponse: fhirclient.TokenResponse): number\n{\n    const now = Math.floor(Date.now() / 1000);\n\n    // Option 1 - using the expires_in property of the token response\n    if (tokenResponse.expires_in) {\n        return now + tokenResponse.expires_in;\n    }\n\n    // Option 2 - using the exp property of JWT tokens (must not assume JWT!)\n    if (tokenResponse.access_token) {\n        let tokenBody = jwtDecode(tokenResponse.access_token);\n        if (tokenBody && tokenBody.exp) {\n            return tokenBody.exp;\n        }\n    }\n\n    // Option 3 - if none of the above worked set this to 5 minutes after now\n    return now + 300;\n}\n\n/**\n * Groups the observations by code. Returns a map that will look like:\n * ```js\n * const map = client.byCodes(observations, \"code\");\n * // map = {\n * //     \"55284-4\": [ observation1, observation2 ],\n * //     \"6082-2\": [ observation3 ]\n * // }\n * ```\n * @param observations Array of observations\n * @param property The name of a CodeableConcept property to group by\n */\nexport function byCode(\n    observations: fhirclient.FHIR.Observation | fhirclient.FHIR.Observation[],\n    property: string\n): fhirclient.ObservationMap\n{\n    const ret: fhirclient.ObservationMap = {};\n\n    function handleCodeableConcept(concept: fhirclient.FHIR.CodeableConcept, observation: fhirclient.FHIR.Observation) {\n        if (concept && Array.isArray(concept.coding)) {\n            concept.coding.forEach(({ code }) => {\n                if (code) {\n                    ret[code] = ret[code] || [] as fhirclient.FHIR.Observation[];\n                    ret[code].push(observation);\n                }\n            });\n        }\n    }\n\n    makeArray(observations).forEach(o => {\n        if (o.resourceType === \"Observation\" && o[property]) {\n            if (Array.isArray(o[property])) {\n                o[property].forEach((concept: fhirclient.FHIR.CodeableConcept) => handleCodeableConcept(concept, o));\n            } else {\n                handleCodeableConcept(o[property], o);\n            }\n        }\n    });\n\n    return ret;\n}\n\n/**\n * First groups the observations by code using `byCode`. Then returns a function\n * that accepts codes as arguments and will return a flat array of observations\n * having that codes. Example:\n * ```js\n * const filter = client.byCodes(observations, \"category\");\n * filter(\"laboratory\") // => [ observation1, observation2 ]\n * filter(\"vital-signs\") // => [ observation3 ]\n * filter(\"laboratory\", \"vital-signs\") // => [ observation1, observation2, observation3 ]\n * ```\n * @param observations Array of observations\n * @param property The name of a CodeableConcept property to group by\n */\nexport function byCodes(\n    observations: fhirclient.FHIR.Observation | fhirclient.FHIR.Observation[],\n    property: string\n): (...codes: string[]) => any[]\n{\n    const bank = byCode(observations, property);\n    return (...codes) => codes\n        .filter(code => (code + \"\") in bank)\n        .reduce(\n            (prev, code) => prev.concat(bank[code + \"\"]),\n            [] as fhirclient.FHIR.Observation[]\n        );\n}\n\n/**\n * Given a conformance statement and a resource type, returns the name of the\n * URL parameter that can be used to scope the resource type by patient ID.\n */\nexport function getPatientParam(conformance: fhirclient.FHIR.CapabilityStatement, resourceType: string): string\n{\n    // Find what resources are supported by this server\n    const resources = getPath(conformance, \"rest.0.resource\") || [];\n\n    // Check if this resource is supported\n    const meta = resources.find((r: any) => r.type === resourceType);\n    if (!meta) {\n        throw new Error(`Resource \"${resourceType}\" is not supported by this FHIR server`);\n    }\n\n    // Check if any search parameters are available for this resource\n    if (!Array.isArray(meta.searchParam)) {\n        throw new Error(`No search parameters supported for \"${resourceType}\" on this FHIR server`);\n    }\n\n    // This is a rare case but could happen in generic workflows\n    if (resourceType == \"Patient\" && meta.searchParam.find((x: any) => x.name == \"_id\")) {\n        return \"_id\";\n    }\n\n    // Now find the first possible parameter name\n    const out = patientParams.find(p => meta.searchParam.find((x: any) => x.name == p));\n\n    // If there is no match\n    if (!out) {\n        throw new Error(\"I don't know what param to use for \" + resourceType);\n    }\n\n    return out;\n}\n\n/**\n * Resolves a reference to target window. It may also open new window or tab if\n * the `target = \"popup\"` or `target = \"_blank\"`.\n * @param target\n * @param width Only used when `target = \"popup\"`\n * @param height Only used when `target = \"popup\"`\n */\nexport async function getTargetWindow(target: fhirclient.WindowTarget, width: number = 800, height: number = 720): Promise<Window>\n{\n    // The target can be a function that returns the target. This can be\n    // used to open a layer pop-up with an iframe and then return a reference\n    // to that iframe (or its name)\n    if (typeof target == \"function\") {\n        target = await target();\n    }\n\n    // The target can be a window reference\n    if (target && typeof target == \"object\") {\n        return target;\n    }\n\n    // At this point target must be a string\n    if (typeof target != \"string\") {\n        _debug(\"Invalid target type '%s'. Failing back to '_self'.\", typeof target);\n        return self;\n    }\n\n    // Current window\n    if (target == \"_self\") {\n        return self;\n    }\n\n    // The parent frame\n    if (target == \"_parent\") {\n        return parent;\n    }\n\n    // The top window\n    if (target == \"_top\") {\n        return top;\n    }\n\n    // New tab or window\n    if (target == \"_blank\") {\n        let error, targetWindow: Window | null = null;\n        try {\n            targetWindow = window.open(\"\", \"SMARTAuthPopup\");\n            if (!targetWindow) {\n                throw new Error(\"Perhaps window.open was blocked\");\n            }\n        } catch (e) {\n            error = e;\n        }\n\n        if (!targetWindow) {\n            _debug(\"Cannot open window. Failing back to '_self'. %s\", error);\n            return self;\n        } else {\n            return targetWindow;\n        }\n    }\n\n    // Popup window\n    if (target == \"popup\") {\n        let error, targetWindow: Window | null = null;\n        // if (!targetWindow || targetWindow.closed) {\n        try {\n            targetWindow = window.open(\"\", \"SMARTAuthPopup\", [\n                \"height=\" + height,\n                \"width=\" + width,\n                \"menubar=0\",\n                \"resizable=1\",\n                \"status=0\",\n                \"top=\" + (screen.height - height) / 2,\n                \"left=\" + (screen.width - width) / 2\n            ].join(\",\"));\n            if (!targetWindow) {\n                throw new Error(\"Perhaps the popup window was blocked\");\n            }\n        } catch (e) {\n            error = e;\n        }\n\n        if (!targetWindow) {\n            _debug(\"Cannot open window. Failing back to '_self'. %s\", error);\n            return self;\n        } else {\n            return targetWindow;\n        }\n    }\n\n    // Frame or window by name\n    const winOrFrame: Window = frames[target as any];\n    if (winOrFrame) {\n        return winOrFrame;\n    }\n\n    _debug(\"Unknown target '%s'. Failing back to '_self'.\", target);\n    return self;\n}\n","import {\n    absolute,\n    debug as _debug,\n    getPath,\n    setPath,\n    jwtDecode,\n    makeArray,\n    request,\n    byCode,\n    byCodes,\n    units,\n    getPatientParam,\n    fetchConformanceStatement,\n    getAccessTokenExpiration,\n    btoa,\n    isBrowser\n} from \"./lib\";\n\nimport { patientCompartment, fhirVersions } from \"./settings\";\nimport HttpError from \"./HttpError\";\nimport { fhirclient } from \"./types\";\n\n// $lab:coverage:off$\n// @ts-ignore\nconst { Response } = typeof FHIRCLIENT_PURE !== \"undefined\" ? window : require(\"cross-fetch\");\n// $lab:coverage:on$\n\nconst debug = _debug.extend(\"client\");\n\n/**\n * Adds patient context to requestOptions object to be used with [[Client.request]]\n * @param requestOptions Can be a string URL (relative to the serviceUrl), or an\n * object which will be passed to fetch()\n * @param client Current FHIR client object containing patient context\n * @return requestOptions object contextualized to current patient\n */\nasync function contextualize(\n    requestOptions: string | URL | fhirclient.RequestOptions,\n    client: Client\n): Promise<fhirclient.RequestOptions>\n{\n    const base = absolute(\"/\", client.state.serverUrl);\n\n    async function contextualURL(_url: URL) {\n        const resourceType = _url.pathname.split(\"/\").pop();\n\n        if (!resourceType) {\n            throw new Error(`Invalid url \"${_url}\"`);\n        }\n\n        if (patientCompartment.indexOf(resourceType) == -1) {\n            throw new Error(`Cannot filter \"${resourceType}\" resources by patient`);\n        }\n\n        const conformance = await fetchConformanceStatement(client.state.serverUrl);\n        const searchParam = getPatientParam(conformance, resourceType);\n        _url.searchParams.set(searchParam, client.patient.id as string);\n        return _url.href;\n    }\n\n    if (typeof requestOptions == \"string\" || requestOptions instanceof URL) {\n        return { url: await contextualURL(new URL(requestOptions + \"\", base)) };\n    }\n\n    requestOptions.url = await contextualURL(new URL(requestOptions.url + \"\", base));\n    return requestOptions;\n}\n\n/**\n * Gets single reference by id. Caches the result.\n * @param refId\n * @param cache A map to store the resolved refs\n * @param client The client instance\n * @param [signal] The `AbortSignal` if any\n * @returns The resolved reference\n * @private\n */\nfunction getRef(\n    refId: string,\n    cache: fhirclient.JsonObject,\n    client: Client,\n    signal?: AbortSignal\n): Promise<fhirclient.JsonObject> {\n    if (!cache[refId]) {\n\n        // Note that we set cache[refId] immediately! When the promise is\n        // settled it will be updated. This is to avoid a ref being fetched\n        // twice because some of these requests are executed in parallel.\n        cache[refId] = client.request({\n            url: refId,\n            signal\n        }).then(res => {\n            cache[refId] = res;\n            return res;\n        }, (error: Error) => {\n            delete cache[refId];\n            throw error;\n        });\n    }\n\n    return Promise.resolve(cache[refId]);\n}\n\n/**\n * Resolves a reference in the given resource.\n * @param obj FHIR Resource\n */\nfunction resolveRef(\n    obj: fhirclient.FHIR.Resource,\n    path: string,\n    graph: boolean,\n    cache: fhirclient.JsonObject,\n    client: Client,\n    signal?: AbortSignal\n) {\n    const node = getPath(obj, path);\n    if (node) {\n        const isArray = Array.isArray(node);\n        return Promise.all(makeArray(node).filter(Boolean).map((item, i) => {\n            const ref = item.reference;\n            if (ref) {\n                return getRef(ref, cache, client, signal).then(sub => {\n                    if (graph) {\n                        if (isArray) {\n                            if (path.indexOf(\"..\") > -1) {\n                                setPath(obj, `${path.replace(\"..\", `.${i}.`)}`, sub);    \n                            } else {\n                                setPath(obj, `${path}.${i}`, sub);\n                            }\n                        } else {\n                            setPath(obj, path, sub);\n                        }\n                    }\n                }).catch((ex) => {\n                    /* ignore missing references */\n                    if (ex.status !== 404) {\n                        throw ex;\n                    }\n                });\n            }\n        }));\n    }\n}\n\n/**\n * Given a resource and a list of ref paths - resolves them all\n * @param obj FHIR Resource\n * @param fhirOptions The fhir options of the initiating request call\n * @param cache A map to store fetched refs\n * @param client The client instance\n * @private\n */\nfunction resolveRefs(\n    obj: fhirclient.FHIR.Resource,\n    fhirOptions: fhirclient.FhirOptions,\n    cache: fhirclient.JsonObject,\n    client: Client,\n    signal?: AbortSignal\n) {\n\n    // 1. Sanitize paths, remove any invalid ones\n    let paths = makeArray(fhirOptions.resolveReferences)\n        .filter(Boolean) // No false, 0, null, undefined or \"\"\n        .map(path => String(path).trim())\n        .filter(Boolean); // No space-only strings\n\n    // 2. Remove duplicates\n    paths = paths.filter((p, i) => {\n        const index = paths.indexOf(p, i + 1);\n        if (index > -1) {\n            debug(\"Duplicated reference path \\\"%s\\\"\", p);\n            return false;\n        }\n        return true;\n    });\n\n    // 3. Early exit if no valid paths are found\n    if (!paths.length) {\n        return Promise.resolve();\n    }\n\n    // 4. Group the paths by depth so that child refs are looked up\n    // after their parents!\n    const groups: fhirclient.JsonObject = {};\n    paths.forEach(path => {\n        const len = path.split(\".\").length;\n        if (!groups[len]) {\n            groups[len] = [];\n        }\n        groups[len].push(path);\n    });\n\n    // 5. Execute groups sequentially! Paths within same group are\n    // fetched in parallel!\n    let task: Promise<any> = Promise.resolve();\n    Object.keys(groups).sort().forEach(len => {\n        const group = groups[len];\n        task = task.then(() => Promise.all(group.map((path: string) => {\n            return resolveRef(obj, path, !!fhirOptions.graph, cache, client, signal);\n        })));\n    });\n    return task;\n}\n\nexport const msg = {\n    noPatientBeforeAuth       : \"Cannot get the ID of the selected patient before the app is authorized\",\n    noPatientFromOpenServer   : \"Cannot get the ID of the selected patient from an open FHIR server\",\n    noPatientScopes           : \"Unable to get the ID of the selected patient. Insufficient scopes. 'launch' or 'launch/patient' scope is needed.\",\n    noPatientAvailable        : \"The ID of the selected patient is not available. Please check if the server supports that.\",\n\n    noEncounterBeforeAuth     : \"Cannot get the ID of the selected encounter before the app is authorized\",\n    noEncounterFromOpenServer : \"Cannot get the ID of the selected encounter from an open FHIR server\",\n    noEncounterScopes         : \"Unable to get the ID of the selected encounter. Insufficient scopes. 'launch' or 'launch/encounter' scope is needed.\",\n    noEncounterAvailable      : \"The ID of the selected encounter is not available. Check if this server supports encounter context, and if the selected patient has any recorded encounters.\",\n\n    noUserBeforeAuth          : \"Cannot get the current user before the app is authorized\",\n    noUserFromOpenServer      : \"Cannot get the current user from an open FHIR server\",\n    noUserScopes              : \"Unable to get the current user. Insufficient scopes. 'openid fhirUser' or 'openid profile' scopes are needed.\",\n    noUserAvailable           : \"The current user is not available. Check if this server supports id tokens.\",\n\n    requestNeedsArgs          : \"request requires an url or request options as argument\",\n    appRequiresSMART          : \"This app cannot be accessed directly. Please launch it as SMART app!\",\n    sessionExpiredAndNoRefresh: \"Your session has expired and the useRefreshToken option is set to false. Please re-launch the app.\",\n    sessionExpired            : \"Session expired! Please re-launch the app.\",\n    autoRefreshFailed         : \"Auto-refresh failed! Please re-launch the app.\",\n    requestGot403             : \"Permission denied! Please make sure that you have requested the proper scopes.\",\n    cantRefreshNoToken        : \"Unable to refresh. No refresh_token found.\",\n    cantRefreshNoTokenUri     : \"Unable to refresh. No tokenUri found.\",\n    cantRefreshNoScopes       : \"Unable to refresh. No offline_access or online_access scope found.\",\n    gotNoAccessToken          : \"No access token received\",\n\n    rejectedScopes            : \"The following scopes were requested but not granted by the auth server: \\\"%s\\\"\",\n    noExpiresAt               : \"Auto-refresh might fail! The client got an access token but can't reliably determine when it will expire. The client \" +\n                                \"does not know when that access token was issued. Please also provide an 'expiresAt' state parameter.\"\n};\n\n/**\n * This is a FHIR client that is returned to you from the `ready()` call of the\n * **SMART API**. You can also create it yourself if needed:\n *\n * ```js\n * // BROWSER\n * const client = FHIR.client(\"https://r4.smarthealthit.org\");\n *\n * // SERVER\n * const client = new Client(\"https://r4.smarthealthit.org\");\n * ```\n */\nexport class Client\n{\n    /**\n     * The state of the client instance is an object with various properties.\n     * It contains some details about how the client has been authorized and\n     * determines the behavior of the client instance. If a `storage` is\n     * passed to the constructor, this state will also be persisted there.\n     */\n    readonly state: fhirclient.SMARTState;\n\n    readonly options: fhirclient.ClientOptions = {\n        refreshWithCredentials: \"same-origin\"\n    };\n\n    /**\n     * A SMART app is typically associated with a patient. This is a namespace\n     * for the patient-related functionality of the client.\n     */\n    readonly patient: {\n\n        /**\n         * The ID of the current patient or `null` if there is no current patient\n         */\n        id: string | null\n\n        /**\n         * A method to fetch the current patient resource from the FHIR server.\n         * If there is no patient context, it will reject with an error.\n         * @param {fhirclient.FetchOptions} [requestOptions] Any options to pass to the `fetch` call.\n         * @category Request\n         */\n        read: fhirclient.RequestFunction<fhirclient.FHIR.Patient>\n\n        /**\n         * This is similar to [[Client.request]] but it makes requests in the\n         * context of the current patient. For example, instead of doing\n         * ```js\n         * client.request(\"Observation?patient=\" + client.patient.id)\n         * ```\n         * you can do\n         * ```js\n         * client.patient.request(\"Observation\")\n         * ```\n         * The return type depends on the arguments. Typically it will be the\n         * response payload JSON object. Can also be a string or the `Response`\n         * object itself if we have received a non-json result, which allows us\n         * to handle even binary responses. Can also be a [[CombinedFetchResult]]\n         * object if the `requestOptions.includeResponse`s has been set to true.\n         * @category Request\n         */\n        request: <R = fhirclient.FetchResult>(\n            requestOptions: string|URL|fhirclient.RequestOptions,\n            fhirOptions?: fhirclient.FhirOptions\n        ) => Promise<R>\n\n        /**\n         * This is the FhirJS Patient API. It will ONLY exist if the `Client`\n         * instance is \"connected\" to FhirJS.\n         * @deprecated FhirJS integration will be removed in the next major release\n         */\n        api?: fhirclient.JsonObject\n    };\n\n    /**\n     * The client may be associated with a specific encounter, if the scopes\n     * permit that and if the back-end server supports that. This is a namespace\n     * for encounter-related functionality.\n     */\n    readonly encounter: {\n\n        /**\n         * The ID of the current encounter or `null` if there is no current\n         * encounter\n         */\n        id: string | null\n\n        /**\n         * A method to fetch the current encounter resource from the FHIR server.\n         * If there is no encounter context, it will reject with an error.\n         * @param [requestOptions] Any options to pass to the `fetch` call.\n         * @category Request\n         */\n        read: fhirclient.RequestFunction<fhirclient.FHIR.Encounter>\n    };\n\n    /**\n     * The client may be associated with a specific user, if the scopes\n     * permit that. This is a namespace for user-related functionality.\n     */\n    readonly user: {\n\n        /**\n         * The ID of the current user or `null` if there is no current user\n         */\n        id: string | null\n\n        /**\n         * A method to fetch the current user resource from the FHIR server.\n         * If there is no user context, it will reject with an error.\n         * @param [requestOptions] Any options to pass to the `fetch` call.\n         * @category Request\n         */\n        read: fhirclient.RequestFunction<\n            fhirclient.FHIR.Patient |\n            fhirclient.FHIR.Practitioner |\n            fhirclient.FHIR.RelatedPerson\n        >\n\n        /**\n         * Returns the profile of the logged_in user (if any), or null if the\n         * user is not available. This is a string having the shape\n         * `{user type}/{user id}`. For example `Practitioner/abc` or\n         * `Patient/xyz`.\n         * @alias client.getFhirUser()\n         */\n        fhirUser: string | null\n\n        /**\n         * Returns the type of the logged-in user or null. The result can be\n         * `Practitioner`, `Patient` or `RelatedPerson`.\n         * @alias client.getUserType()\n         */\n        resourceType: string | null\n    };\n\n    /**\n     * The [FhirJS](https://github.com/FHIR/fhir.js/blob/master/README.md) API.\n     * **NOTE:** This will only be available if `fhir.js` is used. Otherwise it\n     * will be `undefined`.\n     * @deprecated FhirJS integration will be removed in the next major release\n     */\n    api: fhirclient.JsonObject | undefined;\n\n    /**\n     * Refers to the refresh task while it is being performed.\n     * @see [[refresh]]\n     */\n    private _refreshTask: Promise<any> | null = null;\n\n    /**\n     * - Validates parameters\n     * - Creates an instance\n     * - If in browser, tries to connect it to FhirJS, if one is available globally\n     * - Initializes the `patient`, `user` and `encounter` APIs\n     * - Checks for rejected scopes\n     */\n    constructor(state: fhirclient.SMARTState | string, options: fhirclient.ClientOptions = {})\n    {\n        if (typeof state == \"string\") {\n            state = { serverUrl: state } as fhirclient.SMARTState\n        }\n\n        // Valid serverUrl is required!\n        if (!state.serverUrl || !state.serverUrl.match(/https?:\\/\\/.+/)) {\n            throw new Error(\"A \\\"serverUrl\\\" option is required and must begin with \\\"http(s)\\\"\");\n        }\n\n        Object.assign(this.options, options);\n\n        this.state = state;\n\n        const client = this;\n\n        // patient api ---------------------------------------------------------\n        this.patient = {\n            get id() { return client.getPatientId(); },\n            read: (requestOptions) => {\n                const id = this.patient.id;\n                return id ?\n                    this.request({ ...requestOptions, url: `Patient/${id}` }) :\n                    Promise.reject(new Error(\"Patient is not available\"));\n            },\n            request: (requestOptions, fhirOptions = {}) => {\n                if (this.patient.id) {\n                    return (async () => {\n                        const options = await contextualize(requestOptions, this);\n                        return this.request(options, fhirOptions);\n                    })();\n                } else {\n                    return Promise.reject(new Error(\"Patient is not available\"));\n                }\n            }\n        };\n\n        // encounter api -------------------------------------------------------\n        this.encounter = {\n            get id() { return client.getEncounterId(); },\n            read: requestOptions => {\n                const id = this.encounter.id;\n                return id ?\n                    this.request({ ...requestOptions, url: `Encounter/${id}` }) :\n                    Promise.reject(new Error(\"Encounter is not available\"));\n            }\n        };\n\n        // user api ------------------------------------------------------------\n        this.user = {\n            get fhirUser() { return client.getFhirUser(); },\n            get id() { return client.getUserId(); },\n            get resourceType() { return client.getUserType(); },\n            read: requestOptions => {\n                const fhirUser = this.user.fhirUser;\n                return fhirUser ?\n                    this.request({ ...requestOptions, url: fhirUser }) :\n                    Promise.reject(new Error(\"User is not available\"));\n            }\n        };\n\n        // fhir.js api (attached automatically in browser)\n        // ---------------------------------------------------------------------\n        if (isBrowser()) {\n            // @ts-ignore\n            this.connect(window.fhir);\n        }\n\n        this.checkScopes()\n\n        if (!this.state.expiresAt &&\n            this.state.tokenUri &&\n            this.state.tokenResponse?.access_token &&\n            this.state.tokenResponse?.refresh_token &&\n            (this.hasGrantedScope(\"offline_access\") || this.hasGrantedScope(\"online_access\"))\n        ) {\n            console.warn(msg.noExpiresAt)\n        }\n    }\n\n    /**\n     * This method is used to make the \"link\" between the `fhirclient` and the\n     * `fhir.js`, if one is available.\n     * **Note:** This is called by the constructor. If fhir.js is available in\n     * the global scope as `fhir`, it will automatically be linked to any [[Client]]\n     * instance. You should only use this method to connect to `fhir.js` which\n     * is not global.\n     */\n    connect(fhirJs?: (options: fhirclient.JsonObject) => fhirclient.JsonObject): Client\n    {\n        if (typeof fhirJs == \"function\") {\n            const options: fhirclient.JsonObject = {\n                baseUrl: this.state.serverUrl.replace(/\\/$/, \"\")\n            };\n\n            const accessToken = this.getState(\"tokenResponse.access_token\");\n            if (accessToken) {\n                options.auth = { token: accessToken };\n            }\n            else {\n                const { username, password } = this.state;\n                if (username && password) {\n                    options.auth = {\n                        user: username,\n                        pass: password\n                    };\n                }\n            }\n            this.api = fhirJs(options);\n\n            const patientId = this.getState(\"tokenResponse.patient\");\n            if (patientId) {\n                this.patient.api = fhirJs({\n                    ...options,\n                    patient: patientId\n                });\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Checks if the given scope has been granted\n     */\n    hasGrantedScope(scope: string): boolean\n    {\n        const scopes = String(this.state.tokenResponse?.scope || \"\").trim().split(/\\s+/);\n        return scopes.indexOf(scope) > -1;\n    }\n\n    /**\n     * Checks if the given scope has been requested\n     */\n    hasRequestedScope(scope: string): boolean\n    {\n        const scopes = String(this.state.scope || \"\").trim().split(/\\s+/);\n        return scopes.indexOf(scope) > -1;\n    }\n\n    /**\n     * Compares the requested scopes (from `state.scope`) with the granted\n     * scopes (from `state.tokenResponse.scope`). Emits a warning if any of\n     * the requested scopes was not granted.\n     */\n    checkScopes()\n    {\n        const requestedScopes = String(this.state.scope || \"\").trim().split(/\\s+/).filter(Boolean);\n        const grantedScopes = String(this.state.tokenResponse?.scope || \"\").trim().split(/\\s+/);\n        const rejectedScopes = []\n        for (const requested of requestedScopes) {\n            if (grantedScopes.indexOf(requested) === -1) {\n                rejectedScopes.push(requested)\n            }\n        }\n        if (rejectedScopes.length) {\n            console.warn(msg.rejectedScopes, rejectedScopes.join('\", \"'))\n        }\n    }\n\n    /**\n     * Returns the ID of the selected patient or null. You should have requested\n     * \"launch/patient\" scope. Otherwise this will return null.\n     */\n    getPatientId(): string | null\n    {\n        const tokenResponse = this.state.tokenResponse;\n        if (tokenResponse) {\n            if (tokenResponse.patient) {\n                return tokenResponse.patient;\n            }\n            console.warn(\n                this.hasGrantedScope(\"launch\") || this.hasGrantedScope(\"launch/patient\") ?\n                msg.noPatientAvailable :\n                msg.noPatientScopes\n            );\n        } else {\n            console.warn(this.state.authorizeUri ? msg.noPatientBeforeAuth : msg.noPatientFromOpenServer);\n        }\n        return null;\n    }\n\n    /**\n     * Returns the ID of the selected encounter or null. You should have\n     * requested \"launch/encounter\" scope. Otherwise this will return null.\n     * Note that not all servers support the \"launch/encounter\" scope so this\n     * will be null if they don't.\n     */\n    getEncounterId(): string | null\n    {\n        const tokenResponse = this.state.tokenResponse;\n        if (tokenResponse) {\n            if (tokenResponse.encounter) {\n                return tokenResponse.encounter;\n            }\n            console.warn(\n                this.hasGrantedScope(\"launch\") || this.hasGrantedScope(\"launch/encounter\") ?\n                msg.noEncounterAvailable :\n                msg.noEncounterScopes\n            );\n        } else {\n            console.warn(this.state.authorizeUri ? msg.noEncounterBeforeAuth : msg.noEncounterFromOpenServer);\n        }\n        return null;\n    }\n\n    /**\n     * Returns the (decoded) id_token if any. You need to request \"openid\" and\n     * \"profile\" scopes if you need to receive an id_token (if you need to know\n     * who the logged-in user is).\n     */\n    getIdToken(): fhirclient.IDToken | null\n    {\n        const tokenResponse = this.state.tokenResponse;\n        if (tokenResponse) {\n            const idToken = tokenResponse.id_token;\n\n            // We have been authorized against this server but we don't have\n            // the id_token. This should be a scope issue.\n            if (!idToken) {\n                const hasOpenid   = this.hasGrantedScope(\"openid\");\n                const hasProfile  = this.hasGrantedScope(\"profile\");\n                const hasFhirUser = this.hasGrantedScope(\"fhirUser\");\n                console.warn(hasOpenid && (hasFhirUser || hasProfile) ? msg.noUserAvailable : msg.noUserScopes);\n                return null;\n            }\n\n            return jwtDecode(idToken) as fhirclient.IDToken;\n        }\n\n        console.warn(this.state.authorizeUri ? msg.noUserBeforeAuth : msg.noUserFromOpenServer);\n        return null;\n    }\n\n    /**\n     * Returns the profile of the logged_in user (if any). This is a string\n     * having the following shape `\"{user type}/{user id}\"`. For example:\n     * `\"Practitioner/abc\"` or `\"Patient/xyz\"`.\n     */\n    getFhirUser(): string | null\n    {\n        const idToken = this.getIdToken();\n        if (idToken) {\n            return idToken.fhirUser || idToken.profile;\n        }\n        return null;\n    }\n\n    /**\n     * Returns the user ID or null.\n     */\n    getUserId(): string | null\n    {\n        const profile = this.getFhirUser();\n        if (profile) {\n            return profile.split(\"/\")[1];\n        }\n        return null;\n    }\n\n    /**\n     * Returns the type of the logged-in user or null. The result can be\n     * \"Practitioner\", \"Patient\" or \"RelatedPerson\".\n     */\n    getUserType(): string | null\n    {\n        const profile = this.getFhirUser();\n        if (profile) {\n            return profile.split(\"/\")[0];\n        }\n        return null;\n    }\n\n    /**\n     * Builds and returns the value of the `Authorization` header that can be\n     * sent to the FHIR server\n     */\n    getAuthorizationHeader(): string | null\n    {\n        const accessToken = this.getState(\"tokenResponse.access_token\");\n        if (accessToken) {\n            return \"Bearer \" + accessToken;\n        }\n        const { username, password } = this.state;\n        if (username && password) {\n            return \"Basic \" + btoa(username + \":\" + password);\n        }\n        return null;\n    }\n\n    /**\n     * Calls the `save` callback option (if one is provided) to persist the instance\n     * - In browsers, clients returned by smart.ready or smart.init will persist in\n     *   sessionStorage\n     * - In servers, clients returned by smart.ready or smart.init will persist in\n     *   the request session (unless configured otherwise)\n     * - Direct Client instances will not persist anywhere, unless a `save` option\n     *   is passed to the constructor\n     */\n    async saveState()\n    {\n        if (this.options.save) {\n            await this.options.save(this.state)\n        }\n    }\n\n    /**\n     * Creates a new resource in a server-assigned location\n     * @see http://hl7.org/fhir/http.html#create\n     * @param resource A FHIR resource to be created\n     * @param [requestOptions] Any options to be passed to the fetch call.\n     * Note that `method` and `body` will be ignored.\n     * @category Request\n     */\n    create<R = fhirclient.FHIR.Resource, O extends fhirclient.FetchOptions = {}>(\n        resource: fhirclient.FHIR.Resource,\n        requestOptions?: O\n    ): Promise<O[\"includeResponse\"] extends true ? fhirclient.CombinedFetchResult<R> : R>\n    {\n        return this.request({\n            ...requestOptions,\n            url: `${resource.resourceType}`,\n            method: \"POST\",\n            body: JSON.stringify(resource),\n            headers: {\n                // TODO: Do we need to alternate with \"application/json+fhir\"?\n                \"Content-Type\": \"application/json\",\n                ...(requestOptions || {}).headers\n            }\n        });\n    }\n\n    /**\n     * Creates a new current version for an existing resource or creates an\n     * initial version if no resource already exists for the given id.\n     * @see http://hl7.org/fhir/http.html#update\n     * @param resource A FHIR resource to be updated\n     * @param requestOptions Any options to be passed to the fetch call.\n     * Note that `method` and `body` will be ignored.\n     * @category Request\n     */\n    update<R = fhirclient.FHIR.Resource, O extends fhirclient.FetchOptions = {}>(\n        resource: fhirclient.FHIR.Resource,\n        requestOptions?: O\n    ): Promise<O[\"includeResponse\"] extends true ? fhirclient.CombinedFetchResult<R> : R>\n    {\n        return this.request({\n            ...requestOptions,\n            url: `${resource.resourceType}/${resource.id}`,\n            method: \"PUT\",\n            body: JSON.stringify(resource),\n            headers: {\n                // TODO: Do we need to alternate with \"application/json+fhir\"?\n                \"Content-Type\": \"application/json\",\n                ...(requestOptions || {}).headers\n            }\n        });\n    }\n\n    /**\n     * Removes an existing resource.\n     * @see http://hl7.org/fhir/http.html#delete\n     * @param url Relative URI of the FHIR resource to be deleted\n     * (format: `resourceType/id`)\n     * @param requestOptions Any options (except `method` which will be fixed\n     * to `DELETE`) to be passed to the fetch call.\n     * @category Request\n     */\n    delete<R = unknown>(url: string, requestOptions: fhirclient.FetchOptions = {}): Promise<R>\n    {\n        return this.request<R>({\n            ...requestOptions,\n            url,\n            method: \"DELETE\"\n        });\n    }\n\n    /**\n     * @param requestOptions Can be a string URL (relative to the serviceUrl),\n     * or an object which will be passed to fetch()\n     * @param fhirOptions Additional options to control the behavior\n     * @param _resolvedRefs DO NOT USE! Used internally.\n     * @category Request\n     */\n    async request<T = any>(\n        requestOptions: string|URL|fhirclient.RequestOptions,\n        fhirOptions: fhirclient.FhirOptions = {},\n        _resolvedRefs: fhirclient.JsonObject = {}\n    ): Promise<T>\n    {\n        const debugRequest = _debug.extend(\"client:request\");\n        if (!requestOptions) {\n            throw new Error(msg.requestNeedsArgs);\n        }\n\n        // url -----------------------------------------------------------------\n        let url: string;\n        if (typeof requestOptions == \"string\" || requestOptions instanceof URL) {\n            url = String(requestOptions);\n            requestOptions = {} as fhirclient.RequestOptions;\n        }\n        else {\n            url = String(requestOptions.url);\n        }\n\n        url = absolute(url, this.state.serverUrl);\n\n        const options = {\n            graph: fhirOptions.graph !== false,\n            flat : !!fhirOptions.flat,\n            pageLimit: fhirOptions.pageLimit ?? 1,\n            resolveReferences: (fhirOptions.resolveReferences || []) as string[],\n            useRefreshToken: fhirOptions.useRefreshToken !== false,\n            onPage: typeof fhirOptions.onPage == \"function\" ?\n                fhirOptions.onPage as (\n                    data: fhirclient.JsonObject | fhirclient.JsonObject[],\n                    references?: fhirclient.JsonObject | undefined) => any :\n                undefined\n        };\n\n        const signal = (requestOptions as RequestInit).signal || undefined;\n\n        // Refresh the access token if needed\n        const job = options.useRefreshToken ?\n            this.refreshIfNeeded({ signal }).then(() => requestOptions as fhirclient.RequestOptions) :\n            Promise.resolve(requestOptions as fhirclient.RequestOptions);\n\n        let response: Response | undefined;\n\n        return job\n\n            // Add the Authorization header now, after the access token might\n            // have been updated\n            .then(requestOptions => {\n                const authHeader = this.getAuthorizationHeader();\n                if (authHeader) {\n                    requestOptions.headers = {\n                        ...requestOptions.headers,\n                        Authorization: authHeader\n                    };\n                }\n                return requestOptions;\n            })\n            \n            // Make the request\n            .then(requestOptions => {\n                debugRequest(\n                    \"%s, options: %O, fhirOptions: %O\",\n                    url,\n                    requestOptions,\n                    options\n                );\n                return request<fhirclient.FetchResult>(url, requestOptions).then(result => {\n                    if (requestOptions.includeResponse) {\n                        response = (result as fhirclient.CombinedFetchResult).response;\n                        return (result as fhirclient.CombinedFetchResult).body;\n                    }\n                    return result;\n                });\n            })\n\n            // Handle 401 ------------------------------------------------------\n            .catch(async (error: HttpError) => {\n                if (error.status == 401) {\n\n                    // !accessToken -> not authorized -> No session. Need to launch.\n                    if (!this.getState(\"tokenResponse.access_token\")) {\n                        error.message += \"\\n\" + msg.appRequiresSMART;\n                        throw error;\n                    }\n\n                    // auto-refresh not enabled and Session expired.\n                    // Need to re-launch. Clear state to start over!\n                    if (!options.useRefreshToken) {\n                        debugRequest(msg.sessionExpiredAndNoRefresh);\n                        this.state.tokenResponse = {};\n                        await this.saveState();\n                        error.message += \"\\n\" + msg.sessionExpired;\n                        throw error;\n                    }\n\n                    // In rare cases we may have a valid access token and a refresh\n                    // token and the request might still fail with 401 just because\n                    // the access token has just been revoked.\n\n                    // otherwise -> auto-refresh failed. Session expired.\n                    // Need to re-launch. Clear state to start over!\n                    debugRequest(msg.autoRefreshFailed);\n                    this.state.tokenResponse = {};\n                    await this.saveState();\n                    error.message += \"\\n\" + msg.sessionExpired;\n                    throw error;\n                }\n                throw error;\n            })\n\n            // Handle 403 ------------------------------------------------------\n            .catch((error: HttpError) => {\n                if (error.status == 403) {\n                    debugRequest(msg.requestGot403);\n                }\n                throw error;\n            })\n\n            .then((data: any) => {\n\n                // At this point we don't know what `data` actually is!\n\n                // We might gen an empty or falsy result. If so return it as is\n                if (!data)\n                    return data;\n                \n                // Handle raw responses\n                if (typeof data == \"string\" || data instanceof Response)\n                    return data;\n\n                // Resolve References ------------------------------------------\n                return (async (_data: fhirclient.FHIR.Resource) => {\n\n                    if (_data.resourceType == \"Bundle\") {\n                        await Promise.all(((_data as fhirclient.FHIR.Bundle).entry || []).map(item => resolveRefs(\n                            item.resource,\n                            options,\n                            _resolvedRefs,\n                            this,\n                            signal\n                        )));\n                    }\n                    else {\n                        await resolveRefs(\n                            _data,\n                            options,\n                            _resolvedRefs,\n                            this,\n                            signal\n                        );\n                    }\n\n                    return _data;\n                })(data)\n\n                    // Pagination ----------------------------------------------\n                    .then(async _data => {\n                        if (_data && _data.resourceType == \"Bundle\") {\n                            const links = (_data.link || []) as fhirclient.FHIR.BundleLink[];\n\n                            if (options.flat) {\n                                _data = (_data.entry || []).map(\n                                    (entry: fhirclient.FHIR.BundleEntry) => entry.resource\n                                );\n                            }\n\n                            if (options.onPage) {\n                                await options.onPage(_data, { ..._resolvedRefs });\n                            }\n\n                            if (--options.pageLimit) {\n                                const next = links.find(l => l.relation == \"next\");\n                                _data = makeArray(_data);\n                                if (next && next.url) {\n                                    const nextPage = await this.request(\n                                        {\n                                            url: next.url,\n\n                                            // Aborting the main request (even after it is complete)\n                                            // must propagate to any child requests and abort them!\n                                            // To do so, just pass the same AbortSignal if one is\n                                            // provided.\n                                            signal\n                                        },\n                                        options,\n                                        _resolvedRefs\n                                    );\n\n                                    if (options.onPage) {\n                                        return null;\n                                    }\n\n                                    if (options.resolveReferences.length) {\n                                        Object.assign(_resolvedRefs, nextPage.references);\n                                        return _data.concat(makeArray(nextPage.data || nextPage));\n                                    }\n                                    return _data.concat(makeArray(nextPage));\n                                }\n                            }\n                        }\n                        return _data;\n                    })\n\n                    // Finalize ------------------------------------------------\n                    .then(_data => {\n                        if (options.graph) {\n                            _resolvedRefs = {};\n                        }\n                        else if (!options.onPage && options.resolveReferences.length) {\n                            return {\n                                data: _data,\n                                references: _resolvedRefs\n                            };\n                        }\n                        return _data;\n                    })\n                    .then(_data => {\n                        if ((requestOptions as fhirclient.FetchOptions).includeResponse) {\n                            return {\n                                body: _data,\n                                response\n                            }\n                        }\n                        return _data;\n                    });\n            });\n    }\n\n    /**\n     * Checks if access token and refresh token are present. If they are, and if\n     * the access token is expired or is about to expire in the next 10 seconds,\n     * calls `this.refresh()` to obtain new access token.\n     * @param requestOptions Any options to pass to the fetch call. Most of them\n     * will be overridden, bit it might still be useful for passing additional\n     * request options or an abort signal.\n     * @category Request\n     */\n    refreshIfNeeded(requestOptions: RequestInit = {}): Promise<fhirclient.SMARTState>\n    {\n        const accessToken  = this.getState(\"tokenResponse.access_token\");\n        const refreshToken = this.getState(\"tokenResponse.refresh_token\");\n        const expiresAt    = this.state.expiresAt || 0;\n\n        if (accessToken && refreshToken && expiresAt - 10 < Date.now() / 1000) {\n            return this.refresh(requestOptions);\n        }\n\n        return Promise.resolve(this.state);\n    }\n\n    /**\n     * Use the refresh token to obtain new access token. If the refresh token is\n     * expired (or this fails for any other reason) it will be deleted from the\n     * state, so that we don't enter into loops trying to re-authorize.\n     *\n     * This method is typically called internally from [[Client.request]] if\n     * certain request fails with 401.\n     *\n     * @param requestOptions Any options to pass to the fetch call. Most of them\n     * will be overridden, bit it might still be useful for passing additional\n     * request options or an abort signal.\n     * @category Request\n     */\n    refresh(requestOptions: RequestInit = {}): Promise<fhirclient.SMARTState>\n    {\n        const debugRefresh = _debug.extend(\"client:refresh\");\n        debugRefresh(\"Attempting to refresh with refresh_token...\");\n\n        const refreshToken = this.state?.tokenResponse?.refresh_token;\n        if (!refreshToken) {\n            return Promise.reject(new Error(msg.cantRefreshNoToken));\n        }\n\n        const tokenUri = this.state.tokenUri;\n        if (!tokenUri) {\n            return Promise.reject(new Error(msg.cantRefreshNoTokenUri));\n        }\n\n        const hasOfflineAccess = this.hasGrantedScope(\"offline_access\");\n        const hasOnlineAccess  = this.hasGrantedScope(\"online_access\");\n        if (!hasOfflineAccess && !hasOnlineAccess) {\n            return Promise.reject(new Error(msg.cantRefreshNoScopes));\n        }    \n\n        const refreshRequestOptions = {\n            credentials: this.options.refreshWithCredentials,\n            ...requestOptions,\n            method : \"POST\",\n            mode   : \"cors\" as RequestMode,\n            headers: {\n                ...(requestOptions.headers || {}),\n                \"content-type\": \"application/x-www-form-urlencoded\"\n            },\n            body: `grant_type=refresh_token&refresh_token=${encodeURIComponent(refreshToken)}`\n        };\n\n        // custom authorization header can be passed on manual calls\n        if (!(\"authorization\" in refreshRequestOptions.headers)) {\n            const { clientSecret, clientId } = this.state;\n            if (clientSecret) {\n                // @ts-ignore\n                refreshRequestOptions.headers.authorization = \"Basic \" + btoa(clientId + \":\" + clientSecret);\n            }\n        }\n\n        // This method is typically called internally from `request` if certain\n        // request fails with 401. However, clients will often run multiple\n        // requests in parallel which may result in multiple refresh calls.\n        // To avoid that, we keep a reference to the current refresh task (if any).\n        if (!this._refreshTask) {\n\n            this._refreshTask = request<fhirclient.TokenResponse>(tokenUri, refreshRequestOptions)\n            .then(data => {\n                if (!data.access_token) {\n                    throw new Error(msg.gotNoAccessToken);\n                }\n                debugRefresh(\"Received new access token response %O\", data);\n                Object.assign(this.state.tokenResponse, data);\n                this.state.expiresAt = getAccessTokenExpiration(data);\n                this.checkScopes()\n                return this.state;\n            })\n            .catch((error: Error) => {\n                if (this.state?.tokenResponse?.refresh_token) {\n                    debugRefresh(\"Deleting the expired or invalid refresh token.\");\n                    delete this.state.tokenResponse.refresh_token;\n                }\n                throw error;\n            })\n            .finally(() => {\n                this._refreshTask = null;\n                return this.saveState()\n                    .catch((e) => debugRefresh(e.message))\n                    .then(() => this.state)\n            });\n        }\n\n        return this._refreshTask;\n    }\n\n    // utils -------------------------------------------------------------------\n\n    /**\n     * Groups the observations by code. Returns a map that will look like:\n     * ```js\n     * const map = client.byCodes(observations, \"code\");\n     * // map = {\n     * //     \"55284-4\": [ observation1, observation2 ],\n     * //     \"6082-2\": [ observation3 ]\n     * // }\n     * ```\n     * @param observations Array of observations\n     * @param property The name of a CodeableConcept property to group by\n     * @todo This should be deprecated and moved elsewhere. One should not have\n     * to obtain an instance of [[Client]] just to use utility functions like this.\n     * @deprecated\n     * @category Utility\n     */\n    byCode(\n        observations: fhirclient.FHIR.Observation | fhirclient.FHIR.Observation[],\n        property: string\n    ): fhirclient.ObservationMap\n    {\n        return byCode(observations, property);\n    }\n\n    /**\n     * First groups the observations by code using `byCode`. Then returns a function\n     * that accepts codes as arguments and will return a flat array of observations\n     * having that codes. Example:\n     * ```js\n     * const filter = client.byCodes(observations, \"category\");\n     * filter(\"laboratory\") // => [ observation1, observation2 ]\n     * filter(\"vital-signs\") // => [ observation3 ]\n     * filter(\"laboratory\", \"vital-signs\") // => [ observation1, observation2, observation3 ]\n     * ```\n     * @param observations Array of observations\n     * @param property The name of a CodeableConcept property to group by\n     * @todo This should be deprecated and moved elsewhere. One should not have\n     * to obtain an instance of [[Client]] just to use utility functions like this.\n     * @deprecated\n     * @category Utility\n     */\n    byCodes(\n        observations: fhirclient.FHIR.Observation | fhirclient.FHIR.Observation[],\n        property: string\n    ): (...codes: string[]) => any[]\n    {\n        return byCodes(observations, property);\n    }\n\n    /**\n     * @category Utility\n     */\n    units = units;\n\n    /**\n     * Walks through an object (or array) and returns the value found at the\n     * provided path. This function is very simple so it intentionally does not\n     * support any argument polymorphism, meaning that the path can only be a\n     * dot-separated string. If the path is invalid returns undefined.\n     * @param obj The object (or Array) to walk through\n     * @param path The path (eg. \"a.b.4.c\")\n     * @returns {*} Whatever is found in the path or undefined\n     * @todo This should be deprecated and moved elsewhere. One should not have\n     * to obtain an instance of [[Client]] just to use utility functions like this.\n     * @deprecated\n     * @category Utility\n     */\n    getPath(obj: fhirclient.JsonObject, path = \"\"): any {\n        return getPath(obj, path);\n    }\n\n    /**\n     * Returns a copy of the client state. Accepts a dot-separated path argument\n     * (same as for `getPath`) to allow for selecting specific properties.\n     * Examples:\n     * ```js\n     * client.getState(); // -> the entire state object\n     * client.getState(\"serverUrl\"); // -> the URL we are connected to\n     * client.getState(\"tokenResponse.patient\"); // -> The selected patient ID (if any)\n     * ```\n     * @param path The path (eg. \"a.b.4.c\")\n     * @returns {*} Whatever is found in the path or undefined\n     */\n    getState(path = \"\") {\n        return getPath({ ...this.state }, path);\n    }\n\n    /**\n     * Returns a promise that will be resolved with the fhir version as defined\n     * in the CapabilityStatement.\n     */\n    getFhirVersion(): Promise<string> {\n        return fetchConformanceStatement(this.state.serverUrl)\n            .then((metadata) => metadata.fhirVersion);\n    }\n\n    /**\n     * Returns a promise that will be resolved with the numeric fhir version\n     * - 2 for DSTU2\n     * - 3 for STU3\n     * - 4 for R4\n     * - 0 if the version is not known\n     */\n    getFhirRelease(): Promise<number> {\n        return this.getFhirVersion().then(v => (fhirVersions as fhirclient.JsonObject)[v] || 0);\n    }\n}\n","\n// Note: the following 2 imports appear as unused but they affect how tsc is\n// generating type definitions!\nimport { fhirclient } from \"../types\";\nimport { Client } from \"../Client\";\n\nimport * as util from \"../util\"\n\n// In Browsers we create an adapter, get the SMART api from it and build the\n// global FHIR object\nimport BrowserAdapter from \"../adapters/BrowserAdapter\";\n\nconst adapter = new BrowserAdapter();\nconst { ready, authorize, init, client, options } = adapter.getSmartApi();\n\n// We have two kinds of browser builds - \"pure\" for new browsers and \"legacy\"\n// for old ones. In pure builds we assume that the browser supports everything\n// we need. In legacy mode, the library also acts as a polyfill. Babel will\n// automatically polyfill everything except \"fetch\", which we have to handle\n// manually.\n// @ts-ignore\nif (typeof FHIRCLIENT_PURE == \"undefined\") {\n    const fetch = require(\"cross-fetch\");\n    require(\"abortcontroller-polyfill/dist/abortcontroller-polyfill-only\");\n    if (!window.fetch) {\n        window.fetch    = fetch.default;\n        window.Headers  = fetch.Headers;\n        window.Request  = fetch.Request;\n        window.Response = fetch.Response;\n    }\n}\n\n// $lab:coverage:off$\nconst FHIR = {\n    AbortController: window.AbortController,\n    client,\n    oauth2: {\n        settings: options,\n        ready,\n        authorize,\n        init\n    },\n    util\n};\n\nexport = FHIR;\n// $lab:coverage:on$\n","import { ready, authorize, init } from \"../smart\";\nimport { Client } from \"../Client\";\nimport BrowserStorage from \"../storage/BrowserStorage\";\nimport { fhirclient } from \"../types\";\n\n/**\n * Browser Adapter\n */\nexport default class BrowserAdapter implements fhirclient.Adapter\n{\n    /**\n     * Stores the URL instance associated with this adapter\n     */\n    private _url: URL | null = null;\n\n    /**\n     * Holds the Storage instance associated with this instance\n     */\n    private _storage: fhirclient.Storage | null = null;\n\n    /**\n     * Environment-specific options\n     */\n    options: fhirclient.BrowserFHIRSettings;\n\n    /**\n     * @param options Environment-specific options\n     */\n    constructor(options: fhirclient.BrowserFHIRSettings = {})\n    {\n        this.options = {\n            // Replaces the browser's current URL\n            // using window.history.replaceState API or by reloading.\n            replaceBrowserHistory: true,\n\n            // When set to true, this variable will fully utilize\n            // HTML5 sessionStorage API.\n            // This variable can be overridden to false by setting\n            // FHIR.oauth2.settings.fullSessionStorageSupport = false.\n            // When set to false, the sessionStorage will be keyed\n            // by a state variable. This is to allow the embedded IE browser\n            // instances instantiated on a single thread to continue to\n            // function without having sessionStorage data shared\n            // across the embedded IE instances.\n            fullSessionStorageSupport: true,\n\n            // Do we want to send cookies while making a request to the token\n            // endpoint in order to obtain new access token using existing\n            // refresh token. In rare cases the auth server might require the\n            // client to send cookies along with those requests. In this case\n            // developers will have to change this before initializing the app\n            // like so:\n            // `FHIR.oauth2.settings.refreshTokenWithCredentials = \"include\";`\n            // or\n            // `FHIR.oauth2.settings.refreshTokenWithCredentials = \"same-origin\";`\n            // Can be one of:\n            // \"include\"     - always send cookies\n            // \"same-origin\" - only send cookies if we are on the same domain (default)\n            // \"omit\"        - do not send cookies\n            refreshTokenWithCredentials: \"same-origin\",\n\n            ...options\n        };\n    }\n\n    /**\n     * Given a relative path, returns an absolute url using the instance base URL\n     */\n    relative(path: string): string\n    {\n        return new URL(path, this.getUrl().href).href;\n    }\n\n    /**\n     * In browsers we need to be able to (dynamically) check if fhir.js is\n     * included in the page. If it is, it should have created a \"fhir\" variable\n     * in the global scope.\n     */\n    get fhir()\n    {\n        // @ts-ignore\n        return typeof fhir === \"function\" ? fhir : null;\n    }\n\n    /**\n     * Given the current environment, this method must return the current url\n     * as URL instance\n     */\n    getUrl(): URL\n    {\n        if (!this._url) {\n            this._url = new URL(location + \"\");\n        }\n        return this._url;\n    }\n\n    /**\n     * Given the current environment, this method must redirect to the given\n     * path\n     */\n    redirect(to: string): void\n    {\n        location.href = to;\n    }\n\n    /**\n     * Returns a BrowserStorage object which is just a wrapper around\n     * sessionStorage\n     */\n    getStorage(): BrowserStorage\n    {\n        if (!this._storage) {\n            this._storage = new BrowserStorage();\n        }\n        return this._storage;\n    }\n\n    /**\n     * Returns a reference to the AbortController constructor. In browsers,\n     * AbortController will always be available as global (native or polyfilled)\n     */\n    getAbortController()\n    {\n        return AbortController;\n    }\n\n    /**\n     * Creates and returns adapter-aware SMART api. Not that while the shape of\n     * the returned object is well known, the arguments to this function are not.\n     * Those who override this method are free to require any environment-specific\n     * arguments. For example in node we will need a request, a response and\n     * optionally a storage or storage factory function.\n     */\n    getSmartApi(): fhirclient.SMART\n    {\n        return {\n            ready    : (...args: any[]) => ready(this, ...args),\n            authorize: options => authorize(this, options),\n            init     : options => init(this, options),\n            client   : (state: string | fhirclient.SMARTState) => {\n                if (typeof state === \"string\") {\n                    state = { serverUrl: state }\n                }\n                const client = new Client(state, {\n                    refreshWithCredentials: this.options.refreshTokenWithCredentials\n                })\n                return client\n            },\n            options  : this.options\n        };\n    }\n}\n","/* global window */\nimport {\n    debug as _debug,\n    request,\n    getPath,\n    randomString,\n    getAndCache,\n    fetchConformanceStatement,\n    getAccessTokenExpiration,\n    getTargetWindow,\n    isBrowser,\n    btoa\n} from \"./lib\";\nimport { Client } from \"./Client\";\nimport { SMART_KEY } from \"./settings\";\nimport { fhirclient } from \"./types\";\n\n\nconst debug = _debug.extend(\"oauth2\");\n\nexport { SMART_KEY as KEY };\n\n\n/**\n * Fetches the well-known json file from the given base URL.\n * Note that the result is cached in memory (until the page is reloaded in the\n * browser) because it might have to be re-used by the client\n * @param baseUrl The base URL of the FHIR server\n */\nexport function fetchWellKnownJson(baseUrl = \"/\", requestOptions?: RequestInit): Promise<fhirclient.WellKnownSmartConfiguration>\n{\n    const url = String(baseUrl).replace(/\\/*$/, \"/\") + \".well-known/smart-configuration\";\n    return getAndCache(url, requestOptions).catch((ex: Error) => {\n        throw new Error(`Failed to fetch the well-known json \"${url}\". ${ex.message}`);\n    });\n}\n\n/**\n * Fetch a \"WellKnownJson\" and extract the SMART endpoints from it\n */\nfunction getSecurityExtensionsFromWellKnownJson(baseUrl = \"/\", requestOptions?: RequestInit): Promise<fhirclient.OAuthSecurityExtensions>\n{\n    return fetchWellKnownJson(baseUrl, requestOptions).then(meta => {\n        if (!meta.authorization_endpoint || !meta.token_endpoint) {\n            throw new Error(\"Invalid wellKnownJson\");\n        }\n        return {\n            registrationUri: meta.registration_endpoint  || \"\",\n            authorizeUri   : meta.authorization_endpoint,\n            tokenUri       : meta.token_endpoint\n        };\n    });\n}\n\n/**\n * Fetch a `CapabilityStatement` and extract the SMART endpoints from it\n */\nfunction getSecurityExtensionsFromConformanceStatement(baseUrl = \"/\", requestOptions?: RequestInit): Promise<fhirclient.OAuthSecurityExtensions>\n{\n    return fetchConformanceStatement(baseUrl, requestOptions).then(meta => {\n        const nsUri = \"http://fhir-registry.smarthealthit.org/StructureDefinition/oauth-uris\";\n        const extensions = ((getPath(meta || {}, \"rest.0.security.extension\") || []) as Array<fhirclient.FHIR.Extension<\"valueUri\">>)\n            .filter(e => e.url === nsUri)\n            .map(o => o.extension)[0];\n\n        const out = {\n            registrationUri : \"\",\n            authorizeUri    : \"\",\n            tokenUri        : \"\"\n        };\n\n        if (extensions) {\n            extensions.forEach(ext => {\n                if (ext.url === \"register\") {\n                    out.registrationUri = ext.valueUri;\n                }\n                if (ext.url === \"authorize\") {\n                    out.authorizeUri = ext.valueUri;\n                }\n                if (ext.url === \"token\") {\n                    out.tokenUri = ext.valueUri;\n                }\n            });\n        }\n\n        return out;\n    });\n}\n\ninterface Task {\n    controller: AbortController;\n    promise: Promise<any>;\n    complete?: boolean;\n}\n\n/**\n * This works similarly to `Promise.any()`. The tasks are objects containing a\n * request promise and it's AbortController. Returns a promise that will be\n * resolved with the return value of the first successful request, or rejected\n * with an aggregate error if all tasks fail. Any requests, other than the first\n * one that succeeds will be aborted.\n */\nfunction any(tasks: Task[]): Promise<any> {\n    const len = tasks.length;\n    const errors: Error[] = [];\n    let resolved = false;\n\n    return new Promise((resolve, reject) => {\n\n        function onSuccess(task: Task, result: any) {\n            task.complete = true;\n            if (!resolved) {\n                resolved = true;\n                tasks.forEach(t => {\n                    if (!t.complete) {\n                       t.controller.abort();\n                    }\n                });\n                resolve(result);\n            }\n        }\n\n        function onError(error: Error) {\n            if (errors.push(error) === len) {\n                reject(new Error(errors.map(e => e.message).join(\"; \")));\n            }\n        }\n\n        tasks.forEach(t => {\n            t.promise.then(result => onSuccess(t, result), onError);\n        });\n    });\n}\n\n/**\n * Given a FHIR server, returns an object with it's Oauth security endpoints\n * that we are interested in. This will try to find the info in both the\n * `CapabilityStatement` and the `.well-known/smart-configuration`. Whatever\n * Arrives first will be used and the other request will be aborted.\n * @param [baseUrl] Fhir server base URL\n * @param [env] The Adapter\n */\nexport function getSecurityExtensions(env: fhirclient.Adapter, baseUrl = \"/\"): Promise<fhirclient.OAuthSecurityExtensions>\n{\n    const AbortController = env.getAbortController();\n    const abortController1 = new AbortController();\n    const abortController2 = new AbortController();\n\n    return any([{\n        controller: abortController1,\n        promise: getSecurityExtensionsFromWellKnownJson(baseUrl, {\n            signal: abortController1.signal\n        })\n    }, {\n        controller: abortController2,\n        promise: getSecurityExtensionsFromConformanceStatement(baseUrl, {\n            signal: abortController2.signal\n        })\n    }]);\n}\n\n/**\n * Starts the SMART Launch Sequence.\n * > **IMPORTANT**:\n *   `authorize()` will end up redirecting you to the authorization server.\n *    This means that you should not add anything to the returned promise chain.\n *    Any code written directly after the authorize() call might not be executed\n *    due to that redirect!\n * @param env\n * @param [params]\n */\nexport async function authorize(\n    env: fhirclient.Adapter,\n    params: fhirclient.AuthorizeParams | fhirclient.AuthorizeParams[] = {}\n): Promise<string|void>\n{\n    const url = env.getUrl();\n\n    // Multiple config for EHR launches ---------------------------------------\n    if (Array.isArray(params)) {\n        const urlISS = url.searchParams.get(\"iss\") || url.searchParams.get(\"fhirServiceUrl\");\n        if (!urlISS) {\n            throw new Error(\n                'Passing in an \"iss\" url parameter is required if authorize ' +\n                'uses multiple configurations'\n            );\n        }\n        // pick the right config\n        const cfg = params.find(x => {\n            if (x.issMatch) {\n                if (typeof x.issMatch === \"function\") {\n                    return !!x.issMatch(urlISS);\n                }\n                if (typeof x.issMatch === \"string\") {\n                    return x.issMatch === urlISS;\n                }\n                if (x.issMatch instanceof RegExp) {\n                    return x.issMatch.test(urlISS);\n                }\n            }\n            return false;\n        });\n        if (!cfg) {\n            throw new Error(`No configuration found matching the current \"iss\" parameter \"${urlISS}\"`);\n        }\n        return await authorize(env, cfg);\n    }\n    // ------------------------------------------------------------------------\n\n    // Obtain input\n    const {\n        redirect_uri,\n        clientSecret,\n        fakeTokenResponse,\n        patientId,\n        encounterId,\n        client_id,\n        noRedirect,\n        target,\n        width,\n        height\n    } = params;\n\n    let {\n        iss,\n        launch,\n        fhirServiceUrl,\n        redirectUri,\n        scope = \"\",\n        clientId,\n        completeInTarget\n    } = params;\n\n    const storage = env.getStorage();\n\n    // For these three an url param takes precedence over inline option\n    iss            = url.searchParams.get(\"iss\")            || iss;\n    fhirServiceUrl = url.searchParams.get(\"fhirServiceUrl\") || fhirServiceUrl;\n    launch         = url.searchParams.get(\"launch\")         || launch;\n\n    if (!clientId) {\n        clientId = client_id;\n    }\n\n    if (!redirectUri) {\n        redirectUri = redirect_uri;\n    }\n\n    if (!redirectUri) {\n        redirectUri = env.relative(\".\");\n    } else if (!redirectUri.match(/^https?\\:\\/\\//)) {\n        redirectUri = env.relative(redirectUri);\n    }\n\n    const serverUrl = String(iss || fhirServiceUrl || \"\");\n\n    // Validate input\n    if (!serverUrl) {\n        throw new Error(\n            \"No server url found. It must be specified as `iss` or as \" +\n            \"`fhirServiceUrl` parameter\"\n        );\n    }\n\n    if (iss) {\n        debug(\"Making %s launch...\", launch ? \"EHR\" : \"standalone\");\n    }\n\n    // append launch scope if needed\n    if (launch && !scope.match(/launch/)) {\n        scope += \" launch\";\n    }\n\n    if (isBrowser()) {\n        const inFrame = isInFrame();\n        const inPopUp = isInPopUp();\n\n        if ((inFrame || inPopUp) && completeInTarget !== true && completeInTarget !== false) {\n            \n            // completeInTarget will default to true if authorize is called from\n            // within an iframe. This is to avoid issues when the entire app\n            // happens to be rendered in an iframe (including in some EHRs),\n            // even though that was not how the app developer's intention.\n            completeInTarget = inFrame;\n\n            // In this case we can't always make the best decision so ask devs\n            // to be explicit in their configuration.\n            console.warn(\n                'Your app is being authorized from within an iframe or popup ' +\n                'window. Please be explicit and provide a \"completeInTarget\" ' +\n                'option. Use \"true\" to complete the authorization in the '     +\n                'same window, or \"false\" to try to complete it in the parent ' +\n                'or the opener window. See http://docs.smarthealthit.org/client-js/api.html'\n            );\n        }\n    }\n\n    // If `authorize` is called, make sure we clear any previous state (in case\n    // this is a re-authorize)\n    const oldKey = await storage.get(SMART_KEY);\n    await storage.unset(oldKey);\n\n    // create initial state\n    const stateKey = randomString(16);\n    const state: fhirclient.SMARTState = {\n        clientId,\n        scope,\n        redirectUri,\n        serverUrl,\n        clientSecret,\n        tokenResponse: {},\n        // key: stateKey,\n        completeInTarget\n    };\n\n    const fullSessionStorageSupport = isBrowser() ?\n        getPath(env, \"options.fullSessionStorageSupport\") :\n        true;\n\n    if (fullSessionStorageSupport) {\n        await storage.set(SMART_KEY, stateKey);\n    }\n\n    // fakeTokenResponse to override stuff (useful in development)\n    if (fakeTokenResponse) {\n        Object.assign(state.tokenResponse, fakeTokenResponse);\n    }\n\n    // Fixed patientId (useful in development)\n    if (patientId) {\n        Object.assign(state.tokenResponse, { patient: patientId });\n    }\n\n    // Fixed encounterId (useful in development)\n    if (encounterId) {\n        Object.assign(state.tokenResponse, { encounter: encounterId });\n    }\n\n    let redirectUrl = redirectUri + \"?state=\" + encodeURIComponent(stateKey);\n\n    // bypass oauth if fhirServiceUrl is used (but iss takes precedence)\n    if (fhirServiceUrl && !iss) {\n        debug(\"Making fake launch...\");\n        await storage.set(stateKey, state);\n        if (noRedirect) {\n            return redirectUrl;\n        }\n        return await env.redirect(redirectUrl);\n    }\n\n    // Get oauth endpoints and add them to the state\n    const extensions = await getSecurityExtensions(env, serverUrl);\n    Object.assign(state, extensions);\n    await storage.set(stateKey, state);\n\n    // If this happens to be an open server and there is no authorizeUri\n    if (!state.authorizeUri) {\n        if (noRedirect) {\n            return redirectUrl;\n        }\n        return await env.redirect(redirectUrl);\n    }\n\n    // build the redirect uri\n    const redirectParams = [\n        \"response_type=code\",\n        \"client_id=\"    + encodeURIComponent(clientId || \"\"),\n        \"scope=\"        + encodeURIComponent(scope),\n        \"redirect_uri=\" + encodeURIComponent(redirectUri),\n        \"aud=\"          + encodeURIComponent(serverUrl),\n        \"state=\"        + encodeURIComponent(stateKey)\n    ];\n\n    // also pass this in case of EHR launch\n    if (launch) {\n        redirectParams.push(\"launch=\" + encodeURIComponent(launch));\n    }\n\n    redirectUrl = state.authorizeUri + \"?\" + redirectParams.join(\"&\");\n\n    if (noRedirect) {\n        return redirectUrl;\n    }\n\n    if (target && isBrowser()) {\n        let win: Window;\n\n        win = await getTargetWindow(target, width, height);\n\n        if (win !== self) {\n            try {\n                // Also remove any old state from the target window and then\n                // transfer the current state there\n                win.sessionStorage.removeItem(oldKey);\n                win.sessionStorage.setItem(stateKey, JSON.stringify(state));\n            } catch (ex) {\n                _debug(`Failed to modify window.sessionStorage. Perhaps it is from different origin?. Failing back to \"_self\". %s`, ex);\n                win = self;\n            }\n        }\n\n        if (win !== self) {\n            try {\n                win.location.href = redirectUrl;\n                self.addEventListener(\"message\", onMessage);\n            } catch (ex) {\n                _debug(`Failed to modify window.location. Perhaps it is from different origin?. Failing back to \"_self\". %s`, ex);\n                self.location.href = redirectUrl;\n            }\n        } else {\n            self.location.href = redirectUrl;\n        }\n\n        return;\n    }\n    else {\n        return await env.redirect(redirectUrl);\n    }\n}\n\n/**\n * Checks if called within a frame. Only works in browsers!\n * If the current window has a `parent` or `top` properties that refer to\n * another window, returns true. If trying to access `top` or `parent` throws an\n * error, returns true. Otherwise returns `false`.\n */\nexport function isInFrame() {\n    try {\n        return self !== top && parent !== self;\n    } catch (e) {\n        return true;\n    }\n}\n\n/**\n * Checks if called within another window (popup or tab). Only works in browsers!\n * To consider itself called in a new window, this function verifies that:\n * 1. `self === top` (not in frame)\n * 2. `!!opener && opener !== self` The window has an opener\n * 3. `!!window.name` The window has a `name` set\n */\nexport function isInPopUp() {\n    try {\n        return self === top &&\n               !!opener &&\n               opener !== self &&\n               !!window.name;\n    } catch (e) {\n        return false;\n    }\n}\n\n/**\n * Another window can send a \"completeAuth\" message to this one, making it to\n * navigate to e.data.url\n * @param e The message event\n */\nexport function onMessage(e: MessageEvent) {\n    if (e.data.type == \"completeAuth\" && e.origin === new URL(self.location.href).origin) {\n        window.removeEventListener(\"message\", onMessage);\n        window.location.href = e.data.url;\n    }\n}\n\n/**\n * The completeAuth function should only be called on the page that represents\n * the redirectUri. We typically land there after a redirect from the\n * authorization server..\n */\nexport async function completeAuth(env: fhirclient.Adapter): Promise<Client>\n{\n    const url     = env.getUrl();\n    const Storage = env.getStorage();\n    const params  = url.searchParams;\n\n    let key                    = params.get(\"state\");\n    const code                 = params.get(\"code\");\n    const authError            = params.get(\"error\");\n    const authErrorDescription = params.get(\"error_description\");\n\n    if (!key) {\n        key = await Storage.get(SMART_KEY);\n    }\n\n    // Start by checking the url for `error` and `error_description` parameters.\n    // This happens when the auth server rejects our authorization attempt. In\n    // this case it has no other way to tell us what the error was, other than\n    // appending these parameters to the redirect url.\n    // From client's point of view, this is not very reliable (because we can't\n    // know how we have landed on this page - was it a redirect or was it loaded\n    // manually). However, if `completeAuth()` is being called, we can assume\n    // that the url comes from the auth server (otherwise the app won't work\n    // anyway).\n    if (authError || authErrorDescription) {\n        throw new Error([\n            authError,\n            authErrorDescription\n        ].filter(Boolean).join(\": \"));\n    }\n\n    debug(\"key: %s, code: %s\", key, code);\n\n    // key might be coming from the page url so it might be empty or missing\n    if (!key) {\n        throw new Error(\"No 'state' parameter found. Please (re)launch the app.\");\n    }\n\n    // Check if we have a previous state\n    let state = (await Storage.get(key)) as fhirclient.SMARTState;\n\n    const fullSessionStorageSupport = isBrowser() ?\n        getPath(env, \"options.fullSessionStorageSupport\") :\n        true;\n\n    // If we are in a popup window or an iframe and the authorization is\n    // complete, send the location back to our opener and exit.\n    if (isBrowser() && state && !state.completeInTarget) {\n\n        const inFrame = isInFrame();\n        const inPopUp = isInPopUp();\n\n        // we are about to return to the opener/parent where completeAuth will\n        // be called again. In rare cases the opener or parent might also be\n        // a frame or popup. Then inFrame or inPopUp will be true but we still\n        // have to stop going up the chain. To guard against that weird form of\n        // recursion we pass one additional parameter to the url which we later\n        // remove.\n        if ((inFrame || inPopUp) && !url.searchParams.get(\"complete\")) {\n            url.searchParams.set(\"complete\", \"1\");\n            const { href, origin } = url;\n            if (inFrame) {\n                parent.postMessage({ type: \"completeAuth\", url: href }, origin);\n            }\n            if (inPopUp) {\n                opener.postMessage({ type: \"completeAuth\", url: href }, origin);\n                window.close();\n            }\n\n            return new Promise(() => { /* leave it pending!!! */ });\n        }\n    }\n\n    url.searchParams.delete(\"complete\");\n\n    // Do we have to remove the `code` and `state` params from the URL?\n    const hasState = params.has(\"state\");\n\n    if (isBrowser() && getPath(env, \"options.replaceBrowserHistory\") && (code || hasState)) {\n        // `code` is the flag that tell us to request an access token.\n        // We have to remove it, otherwise the page will authorize on\n        // every load!\n        if (code) {\n            params.delete(\"code\");\n            debug(\"Removed code parameter from the url.\");\n        }\n\n        // If we have `fullSessionStorageSupport` it means we no longer\n        // need the `state` key. It will be stored to a well know\n        // location - sessionStorage[SMART_KEY]. However, no\n        // fullSessionStorageSupport means that this \"well know location\"\n        // might be shared between windows and tabs. In this case we\n        // MUST keep the `state` url parameter.\n        if (hasState && fullSessionStorageSupport) {\n            params.delete(\"state\");\n            debug(\"Removed state parameter from the url.\");\n        }\n\n        // If the browser does not support the replaceState method for the\n        // History Web API, the \"code\" parameter cannot be removed. As a\n        // consequence, the page will (re)authorize on every load. The\n        // workaround is to reload the page to new location without those\n        // parameters. If that is not acceptable replaceBrowserHistory\n        // should be set to false.\n        if (window.history.replaceState) {\n            window.history.replaceState({}, \"\", url.href);\n        }\n    }\n\n    // If the state does not exist, it means the page has been loaded directly.\n    if (!state) {\n        throw new Error(\"No state found! Please (re)launch the app.\");\n    }\n\n    // Assume the client has already completed a token exchange when\n    // there is no code (but we have a state) or access token is found in state\n    const authorized = !code || state.tokenResponse?.access_token;\n\n    // If we are authorized already, then this is just a reload.\n    // Otherwise, we have to complete the code flow\n    if (!authorized && state.tokenUri) {\n\n        if (!code) {\n            throw new Error(\"'code' url parameter is required\");\n        }\n\n        debug(\"Preparing to exchange the code for access token...\");\n        const requestOptions = buildTokenRequest(code, state);\n        debug(\"Token request options: %O\", requestOptions);\n\n        // The EHR authorization server SHALL return a JSON structure that\n        // includes an access token or a message indicating that the\n        // authorization request has been denied.\n        const tokenResponse = await request<fhirclient.TokenResponse>(state.tokenUri, requestOptions);\n        debug(\"Token response: %O\", tokenResponse);\n        if (!tokenResponse.access_token) {\n            throw new Error(\"Failed to obtain access token.\");\n        }\n\n        // Now we need to determine when is this authorization going to expire\n        state.expiresAt = getAccessTokenExpiration(tokenResponse);\n\n        // save the tokenResponse so that we don't have to re-authorize on\n        // every page reload\n        state = { ...state, tokenResponse };\n        await Storage.set(key, state);\n        debug(\"Authorization successful!\");\n    }\n    else {\n        debug(state.tokenResponse?.access_token ?\n            \"Already authorized\" :\n            \"No authorization needed\"\n        );\n    }\n\n    if (fullSessionStorageSupport) {\n        await Storage.set(SMART_KEY, key);\n    }\n\n    const client = new Client(state, { save: (state) => Storage.set(key + \"\", state)});\n    debug(\"Created client instance: %O\", client);\n    return client;\n}\n\n/**\n * Builds the token request options. Does not make the request, just\n * creates it's configuration and returns it in a Promise.\n */\nexport function buildTokenRequest(code: string, state: fhirclient.SMARTState): RequestInit\n{\n    const { redirectUri, clientSecret, tokenUri, clientId } = state;\n\n    if (!redirectUri) {\n        throw new Error(\"Missing state.redirectUri\");\n    }\n\n    if (!tokenUri) {\n        throw new Error(\"Missing state.tokenUri\");\n    }\n\n    if (!clientId) {\n        throw new Error(\"Missing state.clientId\");\n    }\n\n    const requestOptions: fhirclient.JsonObject = {\n        method: \"POST\",\n        headers: { \"content-type\": \"application/x-www-form-urlencoded\" },\n        body: `code=${code}&grant_type=authorization_code&redirect_uri=${\n            encodeURIComponent(redirectUri)}`\n    };\n\n    // For public apps, authentication is not possible (and thus not required),\n    // since a client with no secret cannot prove its identity when it issues a\n    // call. (The end-to-end system can still be secure because the client comes\n    // from a known, https protected endpoint specified and enforced by the\n    // redirect uri.) For confidential apps, an Authorization header using HTTP\n    // Basic authentication is required, where the username is the app’s\n    // client_id and the password is the app’s client_secret (see example).\n    if (clientSecret) {\n        requestOptions.headers.authorization = \"Basic \" + btoa(\n            clientId + \":\" + clientSecret\n        );\n        debug(\"Using state.clientSecret to construct the authorization header: %s\", requestOptions.headers.Authorization);\n    } else {\n        debug(\"No clientSecret found in state. Adding the clientId to the POST body\");\n        requestOptions.body += `&client_id=${encodeURIComponent(clientId)}`;\n    }\n\n    return requestOptions as RequestInit;\n}\n\n/**\n * @param env\n * @param [onSuccess]\n * @param [onError]\n */\nexport async function ready(env: fhirclient.Adapter, onSuccess?: (client: Client) => any, onError?: (error: Error) => any): Promise<Client>\n{\n    let task = completeAuth(env);\n    if (onSuccess) {\n        task = task.then(onSuccess);\n    }\n    if (onError) {\n        task = task.catch(onError);\n    }\n    return task;\n}\n\n/**\n * This function can be used when you want to handle everything in one page\n * (no launch endpoint needed). You can think of it as if it does:\n * ```js\n * authorize(options).then(ready)\n * ```\n *\n * **Be careful with init()!** There are some details you need to be aware of:\n *\n * 1. It will only work if your launch_uri is the same as your redirect_uri.\n *    While this should be valid, we can’t promise that every EHR will allow you\n *    to register client with such settings.\n * 2. Internally, `init()` will be called twice. First it will redirect to the\n *    EHR, then the EHR will redirect back to the page where init() will be\n *    called again to complete the authorization. This is generally fine,\n *    because the returned promise will only be resolved once, after the second\n *    execution, but please also consider the following:\n *    - You should wrap all your app’s code in a function that is only executed\n *      after `init()` resolves!\n *    - Since the page will be loaded twice, you must be careful if your code\n *      has global side effects that can persist between page reloads\n *      (for example writing to localStorage).\n * 3. For standalone launch, only use init in combination with offline_access\n *    scope. Once the access_token expires, if you don’t have a refresh_token\n *    there is no way to re-authorize properly. We detect that and delete the\n *    expired access token, but it still means that the user will have to\n *    refresh the page twice to re-authorize.\n * @param env The adapter\n * @param options The authorize options\n */\nexport async function init(env: fhirclient.Adapter, options: fhirclient.AuthorizeParams | fhirclient.AuthorizeParams[]): Promise<Client|never>\n{\n    const url   = env.getUrl();\n    const code  = url.searchParams.get(\"code\");\n    const state = url.searchParams.get(\"state\");\n\n    // if `code` and `state` params are present we need to complete the auth flow\n    if (code && state) {\n        return completeAuth(env);\n    }\n\n    // Check for existing client state. If state is found, it means a client\n    // instance have already been created in this session and we should try to\n    // \"revive\" it.\n    const storage = env.getStorage();\n    const key     = state || await storage.get(SMART_KEY);\n    const cached  = await storage.get(key);\n    if (cached) {\n        return new Client(cached, {\n            save: (state: fhirclient.SMARTState) => storage.set(key, state)\n        })\n    }\n\n    // Otherwise try to launch\n    return authorize(env, options).then(() => {\n        // `init` promises a Client but that cannot happen in this case. The\n        // browser will be redirected (unload the page and be redirected back\n        // to it later and the same init function will be called again). On\n        // success, authorize will resolve with the redirect url but we don't\n        // want to return that from this promise chain because it is not a\n        // Client instance. At the same time, if authorize fails, we do want to\n        // pass the error to those waiting for a client instance.\n        return new Promise(() => { /* leave it pending!!! */ });\n    });\n}\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","import { fhirclient } from \"./types\";\n\n\nexport default class HttpError extends Error\n{\n    /**\n     * The HTTP status code for this error\n     */\n    statusCode: number;\n\n    /**\n     * The HTTP status code for this error.\n     * Note that this is the same as `status`, i.e. the code is available\n     * through any of these.\n     */\n    status: number;\n\n    /**\n     * The HTTP status text corresponding to this error\n     */\n    statusText: string;\n\n    /**\n     * Reference to the HTTP Response object\n     */\n    response: Response;\n\n    constructor(response: Response) {\n        super(`${response.status} ${response.statusText}\\nURL: ${response.url}`);\n        this.name       = \"HttpError\";\n        this.response   = response;\n        this.statusCode = response.status;\n        this.status     = response.status;\n        this.statusText = response.statusText;\n    }\n\n    async parse()\n    {\n        if (!this.response.bodyUsed) {\n            try {\n                const type = this.response.headers.get(\"Content-Type\") || \"text/plain\";\n                if (type.match(/\\bjson\\b/i)) {\n                    let body = await this.response.json();\n                    if (body.error) {\n                        this.message += \"\\n\" + body.error;\n                        if (body.error_description) {\n                            this.message += \": \" + body.error_description;\n                        }\n                    }\n                    else {\n                        this.message += \"\\n\\n\" + JSON.stringify(body, null, 4);\n                    }\n                }\n                else if (type.match(/^text\\//i)) {\n                    let body = await this.response.text();\n                    if (body) {\n                        this.message += \"\\n\\n\" + body;\n                    }\n                }\n            } catch {\n                // ignore\n            }\n        }\n\n        return this;\n    }\n\n    toJSON() {\n        return {\n            name      : this.name,\n            statusCode: this.statusCode,\n            status    : this.status,\n            statusText: this.statusText,\n            message   : this.message\n        };\n    }\n}\n","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\nfunction log(...args) {\n\t// This hackery is required for IE8/9, where\n\t// the `console.log` function doesn't have 'apply'\n\treturn typeof console === 'object' &&\n\t\tconsole.log &&\n\t\tconsole.log(...args);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* Active `debug` instances.\n\t*/\n\tcreateDebug.instances = [];\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.enabled = createDebug.enabled(namespace);\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = selectColor(namespace);\n\t\tdebug.destroy = destroy;\n\t\tdebug.extend = extend;\n\t\t// Debug.formatArgs = formatArgs;\n\t\t// debug.rawLog = rawLog;\n\n\t\t// env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\tcreateDebug.instances.push(debug);\n\n\t\treturn debug;\n\t}\n\n\tfunction destroy() {\n\t\tconst index = createDebug.instances.indexOf(this);\n\t\tif (index !== -1) {\n\t\t\tcreateDebug.instances.splice(index, 1);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < createDebug.instances.length; i++) {\n\t\t\tconst instance = createDebug.instances[i];\n\t\t\tinstance.enabled = createDebug.enabled(instance.namespace);\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\-?\\d?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","import { fhirclient } from \"../types\";\n\nexport default class Storage\n{\n    /**\n     * Gets the value at `key`. Returns a promise that will be resolved\n     * with that value (or undefined for missing keys).\n     */\n    async get(key: string): Promise<any>\n    {\n        const value = sessionStorage[key];\n        if (value) {\n            return JSON.parse(value);\n        }\n        return undefined;\n    }\n\n    /**\n     * Sets the `value` on `key` and returns a promise that will be resolved\n     * with the value that was set.\n     */\n    async set(key: string, value: any): Promise<any>\n    {\n        sessionStorage[key] = JSON.stringify(value);\n        return value;\n    }\n\n    /**\n     * Deletes the value at `key`. Returns a promise that will be resolved\n     * with true if the key was deleted or with false if it was not (eg. if\n     * did not exist).\n     */\n    async unset(key: string): Promise<boolean>\n    {\n        if (key in sessionStorage) {\n            delete sessionStorage[key];\n            return true;\n        }\n        return false;\n    }\n\n    async clear(): Promise<void>\n    {\n        return sessionStorage.clear()\n    }\n\n    async save(data: fhirclient.JsonObject)\n    {\n        for(const key of Object.keys(data)) {\n            await this.set(key, data[key])\n        }\n        return data\n    }\n}\n","export {\n    byCode,\n    byCodes,\n    getPath,\n    makeArray,\n    setPath,\n    jwtDecode\n} from \"./lib\""],"sourceRoot":""}